
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/defaults.go (0.0%)</option>
				
				<option value="file1">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/register.go (83.3%)</option>
				
				<option value="file2">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/validation.go (0.0%)</option>
				
				<option value="file3">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/defaults.go (100.0%)</option>
				
				<option value="file4">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/register.go (83.3%)</option>
				
				<option value="file5">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/validation.go (100.0%)</option>
				
				<option value="file6">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/config.go (100.0%)</option>
				
				<option value="file7">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/controller.go (57.5%)</option>
				
				<option value="file8">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/errors.go (50.0%)</option>
				
				<option value="file9">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/mutatingwebhook.go (100.0%)</option>
				
				<option value="file10">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/utils.go (97.1%)</option>
				
				<option value="file11">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/validatingwebhook.go (100.0%)</option>
				
				<option value="file12">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/root.go (23.5%)</option>
				
				<option value="file13">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/config.go (100.0%)</option>
				
				<option value="file14">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/errors.go (50.0%)</option>
				
				<option value="file15">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/config.go (94.9%)</option>
				
				<option value="file16">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/daemon.go (39.2%)</option>
				
				<option value="file17">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/node.go (47.5%)</option>
				
				<option value="file18">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/stream.go (35.3%)</option>
				
				<option value="file19">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/utils.go (68.8%)</option>
				
				<option value="file20">github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm/kubeadm.go (75.0%)</option>
				
				<option value="file21">github.com/heathcliff26/kube-upgrade/pkg/upgraded/root.go (14.3%)</option>
				
				<option value="file22">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/rpm-ostree.go (92.0%)</option>
				
				<option value="file23">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/utils.go (100.0%)</option>
				
				<option value="file24">github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils/utils.go (93.3%)</option>
				
				<option value="file25">github.com/heathcliff26/kube-upgrade/pkg/version/version.go (81.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package v1alpha1

const (
        DefaultStatus = "Unknown"
)

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov0" title="0">{
        if spec.Groups == nil </span><span class="cov0" title="0">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                if group.Labels == nil </span><span class="cov0" title="0">{
                        group.Labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">spec.Groups[name] = group</span>
        }
        <span class="cov0" title="0">if spec.Upgraded != nil </span><span class="cov0" title="0">{
                SetObjectDefaults_UpgradedConfig(spec.Upgraded)
        }</span>
}

func SetObjectDefaults_UpgradedConfig(cfg *UpgradedConfig) <span class="cov0" title="0">{
        if cfg.Stream == "" </span><span class="cov0" title="0">{
                cfg.Stream = "ghcr.io/heathcliff26/fcos-k8s"
        }</span>
        <span class="cov0" title="0">if cfg.FleetlockGroup == "" </span><span class="cov0" title="0">{
                cfg.FleetlockGroup = "default"
        }</span>
        <span class="cov0" title="0">if cfg.CheckInterval == "" </span><span class="cov0" title="0">{
                cfg.CheckInterval = "3h"
        }</span>
        <span class="cov0" title="0">if cfg.RetryInterval == "" </span><span class="cov0" title="0">{
                cfg.RetryInterval = "5m"
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha1",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov10" title="2">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(addKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov10" title="2">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package v1alpha1

import (
        "fmt"
        "net/url"
        "regexp"
        "slices"
        "time"
)

var (
        validStatusValues = []string{"Unknown", "Waiting", "Progressing", "Complete"}
)

func ValidateObject_KubeUpgradePlan(plan *KubeUpgradePlan) error <span class="cov0" title="0">{
        err := ValidateObject_KubeUpgradeSpec(plan.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ValidateObject_KubeUpgradeStatus(plan.Status)</span>
}

func ValidateObject_KubeUpgradeSpec(spec KubeUpgradeSpec) error <span class="cov0" title="0">{
        versionRegex := regexp.MustCompile(`^v[0-9]+\.[0-9]+\.[0-9]+$`)
        if !versionRegex.MatchString(spec.KubernetesVersion) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" is not a valid version", spec.KubernetesVersion)
        }</span>

        <span class="cov0" title="0">if len(spec.Groups) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("need at least one node group for upgrades")
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                for _, dependency := range group.DependsOn </span><span class="cov0" title="0">{
                        if _, ok := spec.Groups[dependency]; !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("group \"%s\" depends on non-existing group \"%s\"", name, dependency)
                        }</span>
                }
                <span class="cov0" title="0">if len(group.Labels) &lt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group \"%s\" needs at least one label", name)
                }</span>
                <span class="cov0" title="0">err := ValidateObject_UpgradedConfig(group.Upgraded)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("group \"%s\" has an invalid upgraded config: %v", name, err)
                }</span>
        }

        <span class="cov0" title="0">err := ValidateObject_UpgradedConfig(spec.Upgraded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if spec.Upgraded != nil &amp;&amp; spec.Upgraded.FleetlockURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter spec.upgraded.fleetlock-url")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateObject_UpgradedConfig(cfg *UpgradedConfig) error <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cfg.Stream != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI("http://" + cfg.Stream)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for stream: %v", cfg.Stream, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.FleetlockURL != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI(cfg.FleetlockURL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for fleetlock-url: %v", cfg.FleetlockURL, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.CheckInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.CheckInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for check-interval: %v", cfg.CheckInterval, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.RetryInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.RetryInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for retry-interval: %v", cfg.RetryInterval, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ValidateObject_KubeUpgradeStatus(status KubeUpgradeStatus) error <span class="cov0" title="0">{
        // Mutating/Validation webhooks for subresources are called later, so it is ok if the status does not exist
        if status.Summary == "" &amp;&amp; len(status.Groups) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !slices.Contains(validStatusValues, status.Summary) </span><span class="cov0" title="0">{
                return fmt.Errorf("found unknown status \"%s\" in summary, accepted values are: %v", status.Summary, validStatusValues)
        }</span>

        <span class="cov0" title="0">for group, value := range status.Groups </span><span class="cov0" title="0">{
                if !slices.Contains(validStatusValues, value) </span><span class="cov0" title="0">{
                        return fmt.Errorf("found unknown status \"%s\" in group \"%s\", accepted values are: %v", value, group, validStatusValues)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package v1alpha2

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

const (
        DefaultStatus                 = "Unknown"
        DefaultUpgradedStream         = "ghcr.io/heathcliff26/fcos-k8s"
        DefaultUpgradedFleetlockGroup = "default"
        DefaultUpgradedCheckInterval  = "3h"
        DefaultUpgradedRetryInterval  = "5m"
)

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov9" title="21">{
        if spec.Groups == nil </span><span class="cov2" title="2">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov9" title="21">for name, group := range spec.Groups </span><span class="cov10" title="25">{
                if group.Labels == nil </span><span class="cov4" title="4">{
                        group.Labels = &amp;metav1.LabelSelector{}
                }</span>
                <span class="cov10" title="25">spec.Groups[name] = group</span>
        }
        <span class="cov9" title="21">SetObjectDefaults_UpgradedConfig(&amp;spec.Upgraded)</span>
}

func SetObjectDefaults_UpgradedConfig(cfg *UpgradedConfig) <span class="cov9" title="21">{
        if cfg.Stream == "" </span><span class="cov9" title="20">{
                cfg.Stream = "ghcr.io/heathcliff26/fcos-k8s"
        }</span>
        <span class="cov9" title="21">if cfg.FleetlockGroup == "" </span><span class="cov9" title="21">{
                cfg.FleetlockGroup = "default"
        }</span>
        <span class="cov9" title="21">if cfg.CheckInterval == "" </span><span class="cov9" title="20">{
                cfg.CheckInterval = "3h"
        }</span>
        <span class="cov9" title="21">if cfg.RetryInterval == "" </span><span class="cov9" title="20">{
                cfg.RetryInterval = "5m"
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package v1alpha2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha2",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov10" title="2">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(addKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov10" title="2">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package v1alpha2

import (
        "fmt"
        "net/url"
        "time"

        "golang.org/x/mod/semver"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func ValidateObject_KubeUpgradePlan(plan *KubeUpgradePlan) error <span class="cov10" title="22">{
        return ValidateObject_KubeUpgradeSpec(plan.Spec)
}</span>

func ValidateObject_KubeUpgradeSpec(spec KubeUpgradeSpec) error <span class="cov10" title="22">{
        if !semver.IsValid(spec.KubernetesVersion) </span><span class="cov5" title="5">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" is not a valid semantic version", spec.KubernetesVersion)
        }</span>
        <span class="cov9" title="17">if semver.Prerelease(spec.KubernetesVersion) == "" &amp;&amp; semver.Canonical(spec.KubernetesVersion) != spec.KubernetesVersion </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" needs to be a full version like vX.Y.Z", spec.KubernetesVersion)
        }</span>

        <span class="cov9" title="16">if len(spec.Groups) &lt; 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("need at least one node group for upgrades")
        }</span>
        <span class="cov8" title="15">for name, group := range spec.Groups </span><span class="cov9" title="21">{
                for _, dependency := range group.DependsOn </span><span class="cov6" title="7">{
                        if _, ok := spec.Groups[dependency]; !ok </span><span class="cov1" title="1">{
                                return fmt.Errorf("group \"%s\" depends on non-existing group \"%s\"", name, dependency)
                        }</span>
                }

                <span class="cov9" title="20">if group.Labels == nil || (len(group.Labels.MatchExpressions) &lt; 1 &amp;&amp; len(group.Labels.MatchLabels) &lt; 1) </span><span class="cov1" title="1">{
                        return fmt.Errorf("group \"%s\" needs at least one label selector", name)
                }</span>
                <span class="cov9" title="19">_, err := metav1.LabelSelectorAsSelector(group.Labels)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid label selector for group \"%s\": %v", name, err)
                }</span>

                <span class="cov9" title="18">if group.Upgraded != nil </span><span class="cov3" title="2">{
                        err := ValidateObject_UpgradedConfig(*group.Upgraded)
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("group \"%s\" has an invalid upgraded config: %v", name, err)
                        }</span>
                }
        }

        <span class="cov7" title="11">err := ValidateObject_UpgradedConfig(spec.Upgraded)
        if err != nil </span><span class="cov5" title="4">{
                return err
        }</span>
        <span class="cov6" title="7">if spec.Upgraded.FleetlockURL == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("missing parameter spec.upgraded.fleetlock-url")
        }</span>

        <span class="cov6" title="6">return nil</span>
}

func ValidateObject_UpgradedConfig(cfg UpgradedConfig) error <span class="cov8" title="13">{
        if cfg.Stream != "" </span><span class="cov7" title="9">{
                _, err := url.ParseRequestURI("http://" + cfg.Stream)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for stream: %v", cfg.Stream, err)
                }</span>
        }

        <span class="cov8" title="12">if cfg.FleetlockURL != "" </span><span class="cov7" title="10">{
                _, err := url.ParseRequestURI(cfg.FleetlockURL)
                if err != nil </span><span class="cov3" title="2">{
                        return fmt.Errorf("invalid input \"%s\" for fleetlock-url: %v", cfg.FleetlockURL, err)
                }</span>
        }

        <span class="cov7" title="10">if cfg.CheckInterval != "" </span><span class="cov6" title="7">{
                _, err := time.ParseDuration(cfg.CheckInterval)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for check-interval: %v", cfg.CheckInterval, err)
                }</span>
        }

        <span class="cov7" title="9">if cfg.RetryInterval != "" </span><span class="cov6" title="6">{
                _, err := time.ParseDuration(cfg.RetryInterval)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for retry-interval: %v", cfg.RetryInterval, err)
                }</span>
        }

        <span class="cov7" title="8">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "maps"
        "reflect"
        "strings"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
)

// Combine 2 configs, where group overrides the values used by global.
// Return the result as ready to use annotations.
func combineConfig(global api.UpgradedConfig, group *api.UpgradedConfig) map[string]string <span class="cov8" title="30">{
        if group == nil </span><span class="cov7" title="24">{
                return createConfigAnnotations(global)
        }</span>
        <span class="cov4" title="6">cfg := global

        if group.Stream != "" </span><span class="cov3" title="3">{
                cfg.Stream = group.Stream
        }</span>
        <span class="cov4" title="6">if group.FleetlockURL != "" </span><span class="cov3" title="3">{
                cfg.FleetlockURL = group.FleetlockURL
        }</span>
        <span class="cov4" title="6">if group.FleetlockGroup != "" </span><span class="cov4" title="5">{
                cfg.FleetlockGroup = group.FleetlockGroup
        }</span>
        <span class="cov4" title="6">if group.CheckInterval != "" </span><span class="cov3" title="3">{
                cfg.CheckInterval = group.CheckInterval
        }</span>
        <span class="cov4" title="6">if group.RetryInterval != "" </span><span class="cov3" title="3">{
                cfg.RetryInterval = group.RetryInterval
        }</span>

        <span class="cov4" title="6">return createConfigAnnotations(cfg)</span>
}

// Convert the provided config to node annotations
func createConfigAnnotations(cfg api.UpgradedConfig) map[string]string <span class="cov8" title="30">{
        res := make(map[string]string, 5)

        if cfg.Stream != "" </span><span class="cov5" title="7">{
                res[constants.ConfigStream] = cfg.Stream
        }</span>
        <span class="cov8" title="30">if cfg.FleetlockURL != "" </span><span class="cov5" title="7">{
                res[constants.ConfigFleetlockURL] = cfg.FleetlockURL
        }</span>
        <span class="cov8" title="30">if cfg.FleetlockGroup != "" </span><span class="cov5" title="7">{
                res[constants.ConfigFleetlockGroup] = cfg.FleetlockGroup
        }</span>
        <span class="cov8" title="30">if cfg.CheckInterval != "" </span><span class="cov5" title="7">{
                res[constants.ConfigCheckInterval] = cfg.CheckInterval
        }</span>
        <span class="cov8" title="30">if cfg.RetryInterval != "" </span><span class="cov5" title="7">{
                res[constants.ConfigRetryInterval] = cfg.RetryInterval
        }</span>

        <span class="cov8" title="30">return res</span>
}

// Apply the provided configuration annotations to the node.
// Will delete unspecified config options from node Annotations.
// Returns if the config changed.
func applyConfigAnnotations(annotations map[string]string, cfg map[string]string) bool <span class="cov8" title="33">{
        original := make(map[string]string, len(annotations))
        maps.Copy(original, annotations)

        for k := range annotations </span><span class="cov10" title="63">{
                if strings.HasPrefix(k, constants.ConfigPrefix) </span><span class="cov8" title="32">{
                        delete(annotations, k)
                }</span>
        }

        <span class="cov8" title="33">maps.Copy(annotations, cfg)
        return !reflect.DeepEqual(original, annotations)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controller

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
        "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/scheme"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        "golang.org/x/mod/semver"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        clientv1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/klog/v2"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        "sigs.k8s.io/controller-runtime/pkg/manager/signals"
)

func init() <span class="cov2" title="2">{
        ctrl.SetLogger(klog.NewKlogr())
}</span>

type controller struct {
        client.Client
        manager manager.Manager
        nodes   clientv1.NodeInterface
}

// Run make generate when changing these comments
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans/status,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=nodes,verbs=list;update

func NewController(name string) (*controller, error) <span class="cov1" title="1">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ns, err := GetNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(config, manager.Options{
                Scheme:                        scheme.Scheme,
                LeaderElection:                true,
                LeaderElectionNamespace:       ns,
                LeaderElectionID:              name,
                LeaderElectionReleaseOnCancel: true,
                LeaseDuration:                 Pointer(time.Minute),
                RenewDeadline:                 Pointer(10 * time.Second),
                RetryPeriod:                   Pointer(5 * time.Second),
                HealthProbeBindAddress:        ":9090",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddHealthzCheck("healthz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddReadyzCheck("readyz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;controller{
                manager: mgr,
                nodes:   client.CoreV1().Nodes(),
                Client:  mgr.GetClient(),
        }, nil</span>
}

func (c *controller) Run() error <span class="cov0" title="0">{
        err := ctrl.NewControllerManagedBy(c.manager).For(&amp;api.KubeUpgradePlan{}).Complete(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ctrl.NewWebhookManagedBy(c.manager).
                For(&amp;api.KubeUpgradePlan{}).
                WithDefaulter(&amp;planMutatingHook{}).
                WithValidator(&amp;planValidatingHook{}).
                Complete()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.manager.Start(signals.SetupSignalHandler())</span>
}

func (c *controller) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := klog.LoggerWithValues(klog.NewKlogr(), "plan", req.Name)

        var plan api.KubeUpgradePlan
        err := c.Get(ctx, req.NamespacedName, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to get Plan")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = c.reconcile(ctx, &amp;plan, logger)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = c.Status().Update(ctx, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to update plan status")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{
                Requeue:      plan.Status.Summary != api.PlanStatusComplete,
                RequeueAfter: time.Minute,
        }, nil</span>
}

func (c *controller) reconcile(ctx context.Context, plan *api.KubeUpgradePlan, logger logr.Logger) error <span class="cov7" title="10">{
        if plan.Status.Groups == nil </span><span class="cov4" title="3">{
                plan.Status.Groups = make(map[string]string, len(plan.Spec.Groups))
        }</span>

        <span class="cov7" title="10">nodesToUpdate := make(map[string][]corev1.Node, len(plan.Spec.Groups))
        newGroupStatus := make(map[string]string, len(plan.Spec.Groups))

        for name, cfg := range plan.Spec.Groups </span><span class="cov9" title="24">{
                upgradedCfg := combineConfig(plan.Spec.Upgraded, plan.Spec.Groups[name].Upgraded)

                selector, err := metav1.LabelSelectorAsSelector(cfg.Labels)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to convert labelSelector to selector for listing nodes")
                        return err
                }</span>

                <span class="cov9" title="24">nodeList, err := c.nodes.List(ctx, metav1.ListOptions{
                        LabelSelector: selector.String(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to get nodes for group")
                        return err
                }</span>

                <span class="cov9" title="24">status, update, nodes, err := c.reconcileNodes(plan.Spec.KubernetesVersion, plan.Spec.AllowDowngrade, nodeList.Items, upgradedCfg)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to reconcile nodes for group")
                        return err
                }</span>

                <span class="cov9" title="24">newGroupStatus[name] = status

                if update </span><span class="cov8" title="14">{
                        nodesToUpdate[name] = nodes
                }</span> else<span class="cov7" title="10"> if plan.Status.Groups[name] != newGroupStatus[name] </span><span class="cov5" title="6">{
                        logger.WithValues("group", name, "status", newGroupStatus[name]).Info("Group changed status")
                }</span>
        }

        <span class="cov7" title="10">for name, nodes := range nodesToUpdate </span><span class="cov8" title="14">{
                if groupWaitForDependency(plan.Spec.Groups[name].DependsOn, newGroupStatus) </span><span class="cov5" title="6">{
                        logger.WithValues("group", name).Info("Group is waiting on dependencies")
                        newGroupStatus[name] = api.PlanStatusWaiting
                        continue</span>
                } else<span class="cov6" title="8"> if plan.Status.Groups[name] != newGroupStatus[name] </span><span class="cov5" title="6">{
                        logger.WithValues("group", name, "status", newGroupStatus[name]).Info("Group changed status")
                }</span>

                <span class="cov6" title="8">for _, node := range nodes </span><span class="cov6" title="8">{
                        _, err := c.nodes.Update(ctx, &amp;node, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update node %s: %v", node.GetName(), err)
                        }</span>
                }
        }

        <span class="cov7" title="10">plan.Status.Groups = newGroupStatus
        plan.Status.Summary = createStatusSummary(plan.Status.Groups)

        return nil</span>
}

func (c *controller) reconcileNodes(kubeVersion string, downgrade bool, nodes []corev1.Node, cfgAnnotations map[string]string) (string, bool, []corev1.Node, error) <span class="cov10" title="26">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return api.PlanStatusUnknown, false, nil, nil
        }</span>

        <span class="cov10" title="26">completed := 0
        needUpdate := false
        errorNodes := make([]string, 0)

        for i := range nodes </span><span class="cov10" title="26">{
                if nodes[i].Annotations == nil </span><span class="cov7" title="11">{
                        nodes[i].Annotations = make(map[string]string)
                }</span>

                <span class="cov10" title="26">if applyConfigAnnotations(nodes[i].Annotations, cfgAnnotations) </span><span class="cov2" title="2">{
                        needUpdate = true
                }</span>

                <span class="cov10" title="26">if !downgrade &amp;&amp; semver.Compare(kubeVersion, nodes[i].Status.NodeInfo.KubeletVersion) &lt; 0 </span><span class="cov1" title="1">{
                        return api.PlanStatusError, false, nil, fmt.Errorf("node %s version %s is newer than %s, but downgrade is disabled", nodes[i].GetName(), nodes[i].Status.NodeInfo.KubeletVersion, kubeVersion)
                }</span>

                <span class="cov9" title="25">if nodes[i].Annotations[constants.NodeKubernetesVersion] == kubeVersion </span><span class="cov7" title="12">{
                        if nodes[i].Annotations[constants.NodeUpgradeStatus] == constants.NodeUpgradeStatusCompleted </span><span class="cov7" title="11">{
                                completed++
                        }</span> else<span class="cov1" title="1"> if nodes[i].Annotations[constants.NodeUpgradeStatus] == constants.NodeUpgradeStatusError </span><span class="cov1" title="1">{
                                errorNodes = append(errorNodes, nodes[i].GetName())
                        }</span>
                        <span class="cov7" title="12">continue</span>
                }

                <span class="cov8" title="13">nodes[i].Annotations[constants.NodeKubernetesVersion] = kubeVersion
                nodes[i].Annotations[constants.NodeUpgradeStatus] = constants.NodeUpgradeStatusPending

                needUpdate = true</span>
        }

        <span class="cov9" title="25">var status string
        if len(errorNodes) &gt; 0 </span><span class="cov1" title="1">{
                status = fmt.Sprintf("%s: The nodes %v are reporting errors", api.PlanStatusError, errorNodes)
        }</span> else<span class="cov9" title="24"> if len(nodes) == completed </span><span class="cov7" title="11">{
                status = api.PlanStatusComplete
        }</span> else<span class="cov8" title="13"> {
                status = fmt.Sprintf("%s: %d/%d nodes upgraded", api.PlanStatusProgressing, completed, len(nodes))
        }</span>
        <span class="cov9" title="25">return status, needUpdate, nodes, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controller

import "fmt"

type ErrorGetNamespace struct {
        path string
        err  error
}

func NewErrorGetNamespace(path string, err error) error <span class="cov8" title="1">{
        return &amp;ErrorGetNamespace{
                path: path,
                err:  err,
        }
}</span>

func (e *ErrorGetNamespace) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Could not retrieve namespace from \"%s\": %v", e.path, e.err)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package controller

import (
        "context"
        "fmt"

        "k8s.io/apimachinery/pkg/runtime"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
)

// +kubebuilder:webhook:path=/mutate-kubeupgrade-heathcliff-eu-v1alpha2-kubeupgradeplan,mutating=true,failurePolicy=fail,groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=create;update,versions=v1alpha2,name=kubeupgrade.heathcliff.eu,admissionReviewVersions=v1,sideEffects=None

// planMutatingHook sets the defaults for the plan
type planMutatingHook struct{}

func (*planMutatingHook) Default(_ context.Context, obj runtime.Object) error <span class="cov10" title="22">{
        plan, ok := obj.(*api.KubeUpgradePlan)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("expected a KubeUpgradePlan but got a %T", obj)
        }</span>

        <span class="cov9" title="21">api.SetObjectDefaults_KubeUpgradePlan(plan)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package controller

import (
        "errors"
        "fmt"
        "os"
        "strings"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
)

var serviceAccountNamespaceFile = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"

const namespaceKubeUpgrade = "kube-upgrade"

// Read the namespace from the inserted serviceaccount file. Fallback to default if the file does not exist.
func GetNamespace() (string, error) <span class="cov3" title="3">{
        data, err := os.ReadFile(serviceAccountNamespaceFile)
        if err != nil </span><span class="cov1" title="1">{
                if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return "", NewErrorGetNamespace(serviceAccountNamespaceFile, err)
                }</span> else<span class="cov1" title="1"> {
                        return namespaceKubeUpgrade, nil
                }</span>
        }

        <span class="cov2" title="2">ns := strings.TrimSpace(string(data))
        if len(ns) == 0 </span><span class="cov1" title="1">{
                return "", NewErrorGetNamespace(serviceAccountNamespaceFile, fmt.Errorf("file was empty"))
        }</span>
        <span class="cov1" title="1">return ns, nil</span>
}

// Return a pointer to the variable value
func Pointer[T any](v T) *T <span class="cov1" title="1">{
        return &amp;v
}</span>

// Check if the given group needs to wait on another one
func groupWaitForDependency(deps []string, status map[string]string) bool <span class="cov7" title="17">{
        for _, d := range deps </span><span class="cov7" title="17">{
                if status[d] != api.PlanStatusComplete </span><span class="cov5" title="7">{
                        return true
                }</span>
        }
        <span class="cov6" title="10">return false</span>
}

// Return the status summary from the given input
func createStatusSummary(status map[string]string) string <span class="cov7" title="16">{
        if len(status) == 0 </span><span class="cov1" title="1">{
                return api.PlanStatusUnknown
        }</span>
        <span class="cov7" title="15">waiting := false
        unknown := false
        progressing := make([]string, 0, len(status))
        errorGroups := make([]string, 0, len(status))

        for group, s := range status </span><span class="cov10" title="39">{
                switch </span>{
                case s == api.PlanStatusComplete:<span class="cov8" title="20"></span>
                case strings.HasPrefix(s, api.PlanStatusProgressing):<span class="cov6" title="9">
                        progressing = append(progressing, group)</span>
                case s == api.PlanStatusWaiting:<span class="cov5" title="7">
                        waiting = true</span>
                case strings.HasPrefix(s, api.PlanStatusError):<span class="cov2" title="2">
                        errorGroups = append(errorGroups, group)</span>
                default:<span class="cov1" title="1">
                        unknown = true</span>
                }
        }

        <span class="cov7" title="15">if unknown </span><span class="cov1" title="1">{
                return api.PlanStatusUnknown
        }</span> else<span class="cov7" title="14"> if len(errorGroups) &gt; 0 </span><span class="cov2" title="2">{
                return fmt.Sprintf("%s: Some groups encountered errors %v", api.PlanStatusError, errorGroups)
        }</span> else<span class="cov7" title="12"> if len(progressing) &gt; 0 </span><span class="cov5" title="7">{
                return fmt.Sprintf("%s: Upgrading groups %v", api.PlanStatusProgressing, progressing)
        }</span> else<span class="cov4" title="5"> if waiting </span><span class="cov1" title="1">{
                return api.PlanStatusWaiting
        }</span> else<span class="cov4" title="4"> {
                return api.PlanStatusComplete
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controller

import (
        "context"
        "fmt"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:path=/validate-kubeupgrade-heathcliff-eu-v1alpha2-kubeupgradeplan,mutating=false,failurePolicy=fail,groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=create;update,versions=v1alpha2,name=kubeupgrade.heathcliff.eu,admissionReviewVersions=v1,sideEffects=None

// planValidatingHook validates the plan
type planValidatingHook struct{}

// Validate all values of the plan and check if they are sensible
func (*planValidatingHook) validate(obj runtime.Object) (admission.Warnings, error) <span class="cov10" title="23">{
        plan, ok := obj.(*api.KubeUpgradePlan)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("expected a KubeUpgradePlan but got a %T", obj)
        }</span>

        <span class="cov9" title="22">err := api.ValidateObject_KubeUpgradePlan(plan)
        if err != nil </span><span class="cov8" title="16">{
                return nil, err
        }</span>

        <span class="cov6" title="6">return nil, nil</span>
}

// ValidateCreate validates the object on creation.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (p *planValidatingHook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov2" title="2">{
        return p.validate(obj)
}</span>

// ValidateUpdate validates the object on update.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (p *planValidatingHook) ValidateUpdate(_ context.Context, _ runtime.Object, newObj runtime.Object) (admission.Warnings, error) <span class="cov2" title="2">{
        return p.validate(newObj)
}</span>

// ValidateDelete validates the object on deletion.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (*planValidatingHook) ValidateDelete(_ context.Context, _ runtime.Object) (admission.Warnings, error) <span class="cov1" title="1">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package upgradecontroller

import (
        "github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller"
        "github.com/heathcliff26/kube-upgrade/pkg/version"
        "k8s.io/klog/v2"

        "github.com/spf13/cobra"
)

const Name = "upgrade-controller"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgradeController()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to execute command: %v", err)
        }</span>
}

func NewUpgradeController() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " runs the controller to orchestrate cluster wide kubernetes upgrades.",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        run()
                        return nil
                }</span>,
        }

        <span class="cov8" title="1">rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run() <span class="cov0" title="0">{
        ctrl, err := controller.NewController(Name)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to create controller: %v", err)
        }</span>
        <span class="cov0" title="0">err = ctrl.Run()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Controller exited with error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "log/slog"
        "os"
        "strings"

        "sigs.k8s.io/yaml"
)

const (
        DEFAULT_CONFIG_PATH = "/etc/kube-upgraded/config.yaml"

        DEFAULT_LOG_LEVEL       = "info"
        DEFAULT_KUBECONFIG      = "/etc/kubernetes/kubelet.conf"
        DEFAULT_RPM_OSTREE_PATH = "/usr/bin/rpm-ostree"
        DEFAULT_KUBEADM_PATH    = "/usr/bin/kubeadm"
)

var logLevel = &amp;slog.LevelVar{}

// Initialize the logger
func init() <span class="cov4" title="3">{
        logLevel = &amp;slog.LevelVar{}
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>

type Config struct {
        // The log level used by slog, default "info"
        LogLevel string `json:"logLevel,omitempty"`
        // The path to the kubeconfig file, default is the kubelet config under "/etc/kubernetes/kubelet.conf"
        Kubeconfig string `json:"kubeconfig,omitempty"`
        // The path to the rpm-ostree binary, default "/usr/bin/rpm-ostree"
        RPMOStreePath string `json:"rpm-ostree-path,omitempty"`
        // The path to the kubeadm binary, default "/usr/bin/kubeadm"
        KubeadmPath string `json:"kubeadm-path,omitempty"`
}

// Parse a given string and set the resulting log level
func setLogLevel(level string) error <span class="cov10" title="12">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov4" title="3">
                logLevel.Set(slog.LevelDebug)</span>
        case "info":<span class="cov4" title="3">
                logLevel.Set(slog.LevelInfo)</span>
        case "warn":<span class="cov3" title="2">
                logLevel.Set(slog.LevelWarn)</span>
        case "error":<span class="cov3" title="2">
                logLevel.Set(slog.LevelError)</span>
        default:<span class="cov3" title="2">
                return NewErrUnknownLogLevel(level)</span>
        }
        <span class="cov9" title="10">return nil</span>
}

func DefaultConfig() *Config <span class="cov8" title="8">{
        return &amp;Config{
                LogLevel:      DEFAULT_LOG_LEVEL,
                Kubeconfig:    DEFAULT_KUBECONFIG,
                RPMOStreePath: DEFAULT_RPM_OSTREE_PATH,
                KubeadmPath:   DEFAULT_KUBEADM_PATH,
        }
}</span>

// Loads the config from the given path.
// When path is empty, it checks the default path "/etc/kube-upgraded/config.yaml".
// When no config is found in the default path, it returns the default config.
// Returns error when the given config is invalid.
func LoadConfig(path string) (*Config, error) <span class="cov6" title="5">{
        c := DefaultConfig()

        p := path
        if path == "" </span><span class="cov1" title="1">{
                p = DEFAULT_CONFIG_PATH
        }</span>

        <span class="cov6" title="5">f, err := os.ReadFile(p)
        if os.IsNotExist(err) &amp;&amp; path == "" </span><span class="cov1" title="1">{
                slog.Info("No config file specified and default file does not exist, falling back to default values.", slog.String("default-path", DEFAULT_CONFIG_PATH))
                return c, nil
        }</span> else<span class="cov6" title="4"> if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="3">err = yaml.Unmarshal(f, &amp;c)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">err = setLogLevel(c.LogLevel)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return c, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

type ErrUnknownLogLevel struct {
        level string
}

func NewErrUnknownLogLevel(level string) error <span class="cov10" title="3">{
        return &amp;ErrUnknownLogLevel{
                level: level,
        }
}</span>

func (e *ErrUnknownLogLevel) Error() string <span class="cov0" title="0">{
        return "Unknown log level " + e.level
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
)

// Update the daemon configuration based on the annotations of the node.
// Returns on the first error, but will change all configs before that.
func (d *daemon) UpdateConfigFromNode() error <span class="cov6" title="5">{
        node, err := d.getNode()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov5" title="4">return d.UpdateConfigFromAnnotations(node.GetAnnotations())</span>
}

// Update the daemon configuration from the given annotations.
// Returns on the first error, but will change all configs before that.
func (d *daemon) UpdateConfigFromAnnotations(annotations map[string]string) error <span class="cov10" title="15">{
        for key, value := range annotations </span><span class="cov10" title="15">{
                switch key </span>{
                case constants.ConfigStream:<span class="cov4" title="3">
                        if value == "" </span><span class="cov1" title="1">{
                                return fmt.Errorf("stream annotation %s is empty", constants.ConfigStream)
                        }</span>
                        <span class="cov3" title="2">if d.stream != value </span><span class="cov3" title="2">{
                                slog.Info("Updated stream configuration from node annotation", slog.String("annotation", constants.ConfigStream), slog.String("value", value))
                                d.stream = value
                        }</span>
                case constants.ConfigFleetlockURL:<span class="cov4" title="3">
                        if d.fleetlock.GetURL() != value </span><span class="cov3" title="2">{
                                slog.Info("Updating fleetlock url from node annotation", slog.String("annotation", constants.ConfigFleetlockURL), slog.String("value", value))
                        }</span> else<span class="cov1" title="1"> {
                                continue</span>
                        }

                        <span class="cov3" title="2">err := d.fleetlock.SetURL(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update fleetlock url to \"%s\": %v", value, err)
                        }</span>
                case constants.ConfigFleetlockGroup:<span class="cov3" title="2">
                        if d.fleetlock.GetGroup() != value </span><span class="cov1" title="1">{
                                slog.Info("Updating fleetlock group from node annotation", slog.String("annotation", constants.ConfigFleetlockGroup), slog.String("value", value))
                        }</span> else<span class="cov1" title="1"> {
                                continue</span>
                        }

                        <span class="cov1" title="1">err := d.fleetlock.SetGroup(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update fleetlock group to \"%s\": %v", value, err)
                        }</span>
                case constants.ConfigCheckInterval:<span class="cov3" title="2">
                        interval, err := time.ParseDuration(value)
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to parse \"%s\" as duration: %v", value, err)
                        }</span>
                        <span class="cov1" title="1">if d.checkInterval != interval </span><span class="cov1" title="1">{
                                slog.Info("Updated check interval from node annotation", slog.String("annotation", constants.ConfigStream), slog.String("value", value))
                                d.checkInterval = interval
                        }</span>
                case constants.ConfigRetryInterval:<span class="cov3" title="2">
                        interval, err := time.ParseDuration(value)
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to parse \"%s\" as duration: %v", value, err)
                        }</span>
                        <span class="cov1" title="1">if d.retryInterval != interval </span><span class="cov1" title="1">{
                                slog.Info("Updated retry interval from node annotation", slog.String("annotation", constants.ConfigStream), slog.String("value", value))
                                d.retryInterval = interval
                        }</span>
                default:<span class="cov4" title="3">
                        continue</span>
                }
        }

        <span class="cov9" title="12">if d.fleetlock.GetURL() == "" </span><span class="cov4" title="3">{
                return fmt.Errorf("missing fleetlock server url")
        }</span>

        <span class="cov8" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        fleetlock "github.com/heathcliff26/fleetlock/pkg/client"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm"
        rpmostree "github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/clientcmd"
)

const (
        defaultStream         = "ghcr.io/heathcliff26/fcos-k8s"
        defaultFleetlockGroup = "default"
        defaultCheckInterval  = 3 * time.Hour
        defaultRetryInterval  = 5 * time.Minute
)

type daemon struct {
        fleetlock     *fleetlock.FleetlockClient
        checkInterval time.Duration
        retryInterval time.Duration

        rpmostree *rpmostree.RPMOStreeCMD
        kubeadm   *kubeadm.KubeadmCMD

        stream string
        node   string

        client kubernetes.Interface
        ctx    context.Context
        cancel context.CancelFunc

        upgrade sync.Mutex
}

// Create a new daemon
func NewDaemon(cfg *config.Config) (*daemon, error) <span class="cov7" title="5">{
        fleetlockClient, err := fleetlock.NewEmptyClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create fleetlock client: %v", err)

        }</span>
        <span class="cov7" title="5">err = fleetlockClient.SetGroup(defaultFleetlockGroup)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set fleetlock group: %v", err)
        }</span>

        <span class="cov7" title="5">rpmOstreeCMD, err := rpmostree.New(cfg.RPMOStreePath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create rpm-ostree cmd wrapper: %v", err)
        }</span>
        <span class="cov7" title="4">kubeadmCMD, err := kubeadm.New(cfg.KubeadmPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create kubeadm cmd wrapper: %v", err)
        }</span>

        <span class="cov5" title="3">if cfg.Kubeconfig == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no kubeconfig provided")
        }</span>
        <span class="cov4" title="2">config, err := clientcmd.BuildConfigFromFlags("", cfg.Kubeconfig)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read kubeconfig: %v", err)
        }</span>
        <span class="cov1" title="1">kubeClient, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %v", err)
        }</span>

        <span class="cov1" title="1">machineID, err := utils.GetMachineID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get machine-id: %v", err)
        }</span>
        <span class="cov1" title="1">node, err := findNode(kubeClient, machineID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get kubernetes node name for host: %v", err)
        }</span>
        <span class="cov0" title="0">slog.Info("Found node name for this host", slog.String("node", node))

        return &amp;daemon{
                fleetlock:     fleetlockClient,
                checkInterval: defaultCheckInterval,
                retryInterval: defaultRetryInterval,

                rpmostree: rpmOstreeCMD,
                kubeadm:   kubeadmCMD,

                stream: defaultStream,
                node:   node,
                client: kubeClient,
        }, nil</span>
}

// Retries the given function until it succeeds
func (d *daemon) retry(f func() bool) <span class="cov5" title="3">{
        for !f() </span><span class="cov10" title="8">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-time.After(d.retryInterval):<span class="cov9" title="7"></span>
                }
        }
}

// Will try to release the lock until successfull
func (d *daemon) releaseLock() <span class="cov1" title="1">{
        d.retry(func() bool </span><span class="cov1" title="1">{
                err := d.fleetlock.Release()
                if err == nil </span><span class="cov1" title="1">{
                        return true
                }</span>

                <span class="cov0" title="0">slog.Warn("Failed to release lock", "err", err)
                return false</span>
        })
}

// Run the main daemon loop
func (d *daemon) Run() error <span class="cov0" title="0">{
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
        ctx, cancel := context.WithCancel(context.Background())
        d.ctx = ctx
        d.cancel = cancel
        go func() </span><span class="cov0" title="0">{
                &lt;-stop
                cancel()
        }</span>()

        <span class="cov0" title="0">node, err := d.getNode()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get node status: %v", err)
        }</span>

        <span class="cov0" title="0">err = d.UpdateConfigFromAnnotations(node.GetAnnotations())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update daemon config from node annotations: %v", err)
        }</span>

        <span class="cov0" title="0">node, err = d.annotateNodeWithUpgradedVersion(node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to annotate node with upgraded version: %v", err)
        }</span>

        <span class="cov0" title="0">if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                slog.Debug("Releasing any log that may be held by this machine")
                d.releaseLock()
                if d.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                slog.Info("Node needs upgrade or is in the middle of one, upgrading node before starting daemon")
                d.doNodeUpgradeWithRetry(node)
        }</span>

        <span class="cov0" title="0">slog.Info("Starting daemon")

        var wg sync.WaitGroup
        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForUpgrade()
                slog.Info("Stopped watching for upgrades")
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForNodeUpgrade()
                slog.Info("Stopped watching for kubernetes upgrades")
        }</span>()

        <span class="cov0" title="0">wg.Wait()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm"
        "github.com/heathcliff26/kube-upgrade/pkg/version"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/tools/cache"
        "sigs.k8s.io/yaml"
)

// Watch for node upgrades and preform them if necessary
func (d *daemon) watchForNodeUpgrade() <span class="cov0" title="0">{
        factory := informers.NewSharedInformerFactoryWithOptions(d.client, time.Minute, informers.WithTweakListOptions(func(opts *metav1.ListOptions) </span><span class="cov0" title="0">{
                opts.FieldSelector = fields.SelectorFromSet(fields.Set{"metadata.name": d.node}).String()
        }</span>))

        <span class="cov0" title="0">informer := factory.Core().V1().Nodes().Informer()
        _, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: func(_, newObj interface{}) </span><span class="cov0" title="0">{
                        node := newObj.(*corev1.Node)
                        d.checkNodeStatus(node)
                }</span>,
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to add event handlers to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">err = informer.SetWatchErrorHandler(cache.DefaultWatchErrorHandler)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to set watch error handler to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">slog.Info("Watching for new kubernetes upgrades")
        informer.Run(d.ctx.Done())</span>
}

// Check if we need to upgrade the node and trigger the upgrade if needed
func (d *daemon) checkNodeStatus(node *corev1.Node) <span class="cov0" title="0">{
        if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d.doNodeUpgradeWithRetry(nil)</span>
}

// Update the node until it succeeds
func (d *daemon) doNodeUpgradeWithRetry(node *corev1.Node) <span class="cov1" title="1">{
        d.retry(func() bool </span><span class="cov4" title="3">{
                err := d.doNodeUpgrade(node)
                if err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov4" title="3">slog.Error("Failed to upgrade node", "err", err, slog.String("node", d.node))
                return false</span>
        })
}

// Update the node by first rebasing to a new version and then upgrading kubernetes
func (d *daemon) doNodeUpgrade(node *corev1.Node) error <span class="cov7" title="6">{
        d.upgrade.Lock()
        defer d.upgrade.Unlock()

        var err error
        if node == nil </span><span class="cov4" title="3">{
                // Need to fetch fresh data here, as the informer might called with a stale node version
                node, err = d.getNode()
                if err != nil </span><span class="cov4" title="3">{
                        return fmt.Errorf("failed to get node data from server: %v", err)
                }</span>
                <span class="cov0" title="0">if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov4" title="3">err = d.UpdateConfigFromAnnotations(node.GetAnnotations())
        if err != nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("failed to update daemon config from node annotations: %v", err))
        }</span>

        <span class="cov4" title="3">version := node.Annotations[constants.NodeKubernetesVersion]
        slog.Info("Attempting node upgrade to new kubernetes version", slog.String("node", node.GetName()), slog.String("version", version))

        err = d.fleetlock.Lock()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to aquire lock: %v", err)
        }</span>

        <span class="cov3" title="2">if version != d.kubeadm.Version() </span><span class="cov3" title="2">{
                slog.Info("Rebasing os to new kubernetes version", slog.String("version", version), slog.String("current", d.kubeadm.Version()))
                err := d.updateNodeStatus(constants.NodeUpgradeStatusRebasing)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update node status: %v", err)
                }</span>
                <span class="cov3" title="2">err = d.rpmostree.Rebase(d.stream + ":" + version)
                if err != nil </span><span class="cov1" title="1">{
                        return d.returnNodeUpgradeError(fmt.Errorf("failed to rebase node: %v", err))
                }</span>
                // This return is here purely for testing, as a successfull rebase does not return, but instead reboots the system
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov0" title="0">slog.Info("Updating node via kubeadm")

        err = d.updateNodeStatus(constants.NodeUpgradeStatusUpgrading)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        <span class="cov0" title="0">kubeadmConfigMap, err := d.client.CoreV1().ConfigMaps("kube-system").Get(d.ctx, "kubeadm-config", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("failed to fetch kubeadm-config: %v", err))
        }</span>
        <span class="cov0" title="0">if kubeadmConfigMap.Data == nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("kubeadm configmap contains no data"))
        }</span>
        <span class="cov0" title="0">var kubeadmConfig kubeadm.ClusterConfiguration
        err = yaml.Unmarshal([]byte(kubeadmConfigMap.Data["ClusterConfiguration"]), &amp;kubeadmConfig)
        if err != nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("failed to parse kubeadm-config: %v", err))
        }</span>

        <span class="cov0" title="0">if version != kubeadmConfig.KubernetesVersion </span><span class="cov0" title="0">{
                slog.Info("kubeadm-config kubernetesVersion does not match requested version, initializing upgrade", slog.String("kubernetesVersion", kubeadmConfig.KubernetesVersion), slog.String("version", version))
                err = d.kubeadm.Apply(version)
        }</span> else<span class="cov0" title="0"> {
                slog.Debug("Cluster upgrade is already initialized, upgrading node")
                err = d.kubeadm.Node()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("failed run kubeadm: %v", err))
        }</span>

        <span class="cov0" title="0">err = d.updateNodeStatus(constants.NodeUpgradeStatusCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        <span class="cov0" title="0">slog.Info("Finished node upgrade, releasing lock")
        d.releaseLock()
        return nil</span>
}

// Update the kube-upgrade node status annotation with the given status
func (d *daemon) updateNodeStatus(status string) error <span class="cov7" title="6">{
        node, err := d.getNode()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov6" title="5">if node.Annotations == nil </span><span class="cov1" title="1">{
                node.Annotations = make(map[string]string)
        }</span>
        <span class="cov6" title="5">node.Annotations[constants.NodeUpgradeStatus] = status

        _, err = d.client.CoreV1().Nodes().Update(d.ctx, node, metav1.UpdateOptions{})
        if err == nil </span><span class="cov6" title="5">{
                slog.Debug("Set node status", slog.String("status", status))
        }</span>
        <span class="cov6" title="5">return err</span>
}

// Retrieve the node from the API
func (d *daemon) getNode() (*corev1.Node, error) <span class="cov10" title="14">{
        return d.client.CoreV1().Nodes().Get(d.ctx, d.node, metav1.GetOptions{})
}</span>

// Return the given error, but also set the node status to error
func (d *daemon) returnNodeUpgradeError(err error) error <span class="cov1" title="1">{
        statusErr := d.updateNodeStatus(constants.NodeUpgradeStatusError)
        if statusErr != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to set node to error status", slog.Any("error", statusErr))
        }</span>
        <span class="cov1" title="1">return err</span>
}

// Annotate the node with the current upgraded version
func (d *daemon) annotateNodeWithUpgradedVersion(node *corev1.Node) (*corev1.Node, error) <span class="cov4" title="3">{
        if node.Annotations == nil </span><span class="cov1" title="1">{
                node.Annotations = make(map[string]string)
        }</span>

        <span class="cov4" title="3">if node.Annotations[constants.NodeUpgradedVersion] == version.Version() </span><span class="cov1" title="1">{
                return node, nil
        }</span>

        <span class="cov3" title="2">node.Annotations[constants.NodeUpgradedVersion] = version.Version()
        return d.client.CoreV1().Nodes().Update(d.ctx, node, metav1.UpdateOptions{})</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"
)

// Check for os upgrades and perform them if necessary.
// Runs until context is cancelled
func (d *daemon) watchForUpgrade() <span class="cov0" title="0">{
        var needUpgrade bool
        for </span><span class="cov0" title="0">{
                d.retry(func() bool </span><span class="cov0" title="0">{
                        var err error
                        slog.Debug("Checking for upgrades via rpm-ostree")
                        needUpgrade, err = d.rpmostree.CheckForUpgrade()
                        if err == nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">slog.Error("Failed to check if there is a new upgrade", "err", err)
                        return false</span>
                })

                <span class="cov0" title="0">if needUpgrade </span><span class="cov0" title="0">{
                        slog.Info("New upgrade is necessary, trying to start update")
                        d.retry(func() bool </span><span class="cov0" title="0">{
                                err := d.doUpgrade()
                                if err == nil </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                                <span class="cov0" title="0">slog.Error("Failed to perform rpm-ostree upgrade", "err", err)
                                return false</span>
                        })
                } else<span class="cov0" title="0"> {
                        slog.Debug("No upgrades found")
                }</span>

                <span class="cov0" title="0">select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(d.checkInterval):<span class="cov0" title="0"></span>
                }
        }
}

// Perform rpm-ostree upgrade
func (d *daemon) doUpgrade() error <span class="cov10" title="3">{
        d.upgrade.Lock()
        defer d.upgrade.Unlock()

        err := d.UpdateConfigFromNode()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update daemon config from node annotations: %v", err)
        }</span>

        <span class="cov10" title="3">err = d.fleetlock.Lock()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to aquire lock: %v", err)
        }</span>

        <span class="cov6" title="2">err = d.rpmostree.Upgrade()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // This should not be reached, as rpmostree.Upgrade() reboots the node on success.
        // I included it here mainly for completness sake.

        <span class="cov1" title="1">d.releaseLock()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"
        "strings"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        authenticationv1 "k8s.io/api/authentication/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

// Find the node. It will try various methods and confirm them via the machine id.
// The methods are in order:
//   - whoami api call
//   - listing all nodes and iterating over them. (This does not work anymore with k8s 1.32+)
func findNode(client kubernetes.Interface, machineID string) (string, error) <span class="cov1" title="1">{
        node, err := findNodeViaWhoami(client, machineID)
        if err == nil </span><span class="cov0" title="0">{
                return node, nil
        }</span>
        <span class="cov1" title="1">slog.Info("Failed to find node via whoami call, trying by listing all nodes next", "err", err)

        return findNodeByListingAllNodes(client, machineID)</span>
}

// Call kubernetes auth api and ask whoami
func findNodeViaWhoami(client kubernetes.Interface, machineID string) (string, error) <span class="cov1" title="1">{
        res, err := client.AuthenticationV1().SelfSubjectReviews().Create(context.Background(), &amp;authenticationv1.SelfSubjectReview{}, metav1.CreateOptions{})
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov0" title="0">name, _ := strings.CutPrefix(res.Status.UserInfo.Username, "system:node:")
        slog.Info("Found username via auth whoami", slog.String("username", res.Status.UserInfo.Username), slog.String("node", name))

        node, err := client.CoreV1().Nodes().Get(context.Background(), name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if node.Status.NodeInfo.MachineID != machineID </span><span class="cov0" title="0">{
                return "", fmt.Errorf("found node \"%s\", but machine id does not match", name)
        }</span>
        <span class="cov0" title="0">return name, nil</span>
}

// Find the node by iterating over all nodes and comparing machine ids
func findNodeByListingAllNodes(client kubernetes.Interface, machineID string) (string, error) <span class="cov5" title="2">{
        nodes, err := client.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov1" title="1">for _, node := range nodes.Items </span><span class="cov1" title="1">{
                if node.Status.NodeInfo.MachineID == machineID </span><span class="cov1" title="1">{
                        return node.GetName(), nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("found no node with matching machineID: %s", machineID)</span>
}

// Check if the node needs to upgrade it's kubernetes version
func nodeNeedsUpgrade(node *corev1.Node) bool <span class="cov10" title="4">{
        if node.Annotations == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="3">status := node.Annotations[constants.NodeUpgradeStatus]
        if status == constants.NodeUpgradeStatusCompleted </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov5" title="2">if _, ok := node.Annotations[constants.NodeKubernetesVersion]; !ok </span><span class="cov1" title="1">{
                slog.Warn("Missing version annotation on node", slog.String("node", node.GetName()), slog.String("annotation", constants.NodeKubernetesVersion))
                return false
        }</span>
        <span class="cov1" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package kubeadm

import (
        "fmt"
        "os/exec"
        "strings"
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type KubeadmCMD struct {
        binary  string
        mutex   sync.Mutex
        version string
}

// Create a new wrapper for kubeadm
func New(path string) (*KubeadmCMD, error) <span class="cov10" title="9">{
        err := utils.CheckExistsAndIsExecutable(path)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov8" title="7">k := &amp;KubeadmCMD{
                binary: path,
        }

        k.version, err = k.getVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read kubeadm version: %v", err)
        }</span>
        <span class="cov8" title="7">k.version, _ = strings.CutSuffix(k.version, "\n")

        return k, nil</span>
}

// Run kubeadm upgrade apply
func (k *KubeadmCMD) Apply(version string) error <span class="cov1" title="1">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateCMDWithStdout(k.binary, "upgrade", "apply", "--yes", version).Run()
}</span>

// Run kubeadm upgrade node
func (k *KubeadmCMD) Node() error <span class="cov0" title="0">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateCMDWithStdout(k.binary, "upgrade", "node").Run()
}</span>

func (k *KubeadmCMD) Version() string <span class="cov6" title="4">{
        return k.version
}</span>

func (k *KubeadmCMD) getVersion() (string, error) <span class="cov8" title="7">{
        out, err := exec.Command(k.binary, "version", "--output", "short").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="7">return string(out), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package upgraded

import (
        "log/slog"
        "os"
        "os/user"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon"
        "github.com/heathcliff26/kube-upgrade/pkg/version"

        "github.com/spf13/cobra"
)

const Name = "upgraded"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgraded()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Command exited with error", "err", err)
                os.Exit(1)
        }</span>
}

func NewUpgraded() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " daemon for keeping the system up-to-date",
                Run: func(cmd *cobra.Command, _ []string) </span><span class="cov0" title="0">{
                        cfg, err := cmd.Flags().GetString("config")
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to parse config file flag", "err", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">run(cfg)</span>
                },
        }

        <span class="cov8" title="1">rootCmd.Flags().StringP("config", "c", "", "Path to config file")
        rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run(cfgPath string) <span class="cov0" title="0">{
        cfg, err := config.LoadConfig(cfgPath)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load config file", "err", err, slog.String("path", cfgPath))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">u, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to check if running as root", "err", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if u.Username != "root" </span><span class="cov0" title="0">{
                slog.Error("Need to be root")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">d, err := daemon.NewDaemon(cfg)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create a new daemon", "err", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = d.Run()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Daemon exited with error", "err", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package rpmostree

import (
        "fmt"
        "os/exec"
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type RPMOStreeCMD struct {
        binary string
        mutex  sync.Mutex
}

// Create a new wrapper for rpm-ostree
func New(path string) (*RPMOStreeCMD, error) <span class="cov10" title="16">{
        err := utils.CheckExistsAndIsExecutable(path)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov9" title="14">return &amp;RPMOStreeCMD{
                binary: path,
        }, nil</span>
}

// Run rpm-ostree and check for new updates
func (r *RPMOStreeCMD) CheckForUpgrade() (bool, error) <span class="cov4" title="3">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        cmd := exec.Command(r.binary, "upgrade", "--check")
        out, err := cmd.CombinedOutput()
        code, ok := getExitCode(err)
        if !ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                fmt.Println(string(out))
                return false, err
        }</span> else<span class="cov4" title="3"> if err == nil </span><span class="cov1" title="1">{
                code = 0
        }</span>

        <span class="cov4" title="3">switch code </span>{
        case 0:<span class="cov1" title="1">
                return true, nil</span>
        case 77:<span class="cov1" title="1">
                return false, nil</span>
        default:<span class="cov1" title="1">
                fmt.Println(string(out))
                return false, fmt.Errorf("rpm-ostree exited with unknown exit code %d", code)</span>
        }
}

// Upgrade the system using rpm-ostree. Writes command output to stdout/stderr.
//
// WARNING: Will reboot the system when successfull.
func (r *RPMOStreeCMD) Upgrade() error <span class="cov3" title="2">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "upgrade", "--reboot").Run()
}</span>

// Rebases the system to the given container image
//
// WARNING: Will reboot the system when successfull.
func (r *RPMOStreeCMD) Rebase(image string) error <span class="cov4" title="3">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "rebase", "--reboot", "ostree-unverified-registry:"+image).Run()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package rpmostree

import (
        "os/exec"
)

// Try to extract the exit code from the error.
func getExitCode(err error) (int, bool) <span class="cov10" title="3">{
        if exiterr, ok := err.(*exec.ExitError); ok </span><span class="cov6" title="2">{
                return exiterr.ExitCode(), true
        }</span>
        <span class="cov1" title="1">return 0, false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
)

// Read the machine-id from /etc/machine-id
func GetMachineID() (string, error) <span class="cov2" title="2">{
        b, err := os.ReadFile("/etc/machine-id")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov2" title="2">machineID := strings.TrimRight(string(b), "\r\n")
        return machineID, nil</span>
}

// Create a command that writes to stdout/stderr
func CreateCMDWithStdout(name string, arg ...string) *exec.Cmd <span class="cov6" title="7">{
        cmd := exec.Command(name, arg...)
        cmd.Stderr = os.Stderr
        cmd.Stdout = os.Stdout
        return cmd
}</span>

// Check if the given file exists and is executable
func CheckExistsAndIsExecutable(path string) error <span class="cov10" title="28">{
        f, err := os.Stat(path)
        if err != nil </span><span class="cov5" title="5">{
                return err
        }</span>
        <span class="cov9" title="23">if f.Mode().Perm()&amp;0100 == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("%s is not an executable", path)
        }</span>
        <span class="cov9" title="22">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package version

import (
        "runtime"
        "runtime/debug"

        "github.com/spf13/cobra"
)

// Create a new version command with the given app name
func NewCommand(name string) *cobra.Command <span class="cov4" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information and exit",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        cmd.Print(VersionInfoString(name))
                }</span>,
        }
        // Override to prevent parent function from running
        <span class="cov4" title="3">cmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span>{<span class="cov0" title="0">}</span>

        <span class="cov4" title="3">return cmd</span>
}

// Return the version string
func Version() string <span class="cov9" title="10">{
        buildinfo, _ := debug.ReadBuildInfo()
        return buildinfo.Main.Version
}</span>

// Return a formated string containing the version, git commit and go version the app was compiled with.
func VersionInfoString(name string) string <span class="cov1" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov10" title="12">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov1" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span> else<span class="cov1" title="1"> if commit == "" </span><span class="cov1" title="1">{
                commit = "Unknown"
        }</span>

        <span class="cov1" title="1">result := name + ":\n"
        result += "    Version: " + buildinfo.Main.Version + "\n"
        result += "    Commit:  " + commit + "\n"
        result += "    Go:      " + runtime.Version() + "\n"

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
