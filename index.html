
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>upgrade-controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/kube-upgrade/cmd/upgrade-controller/main.go (0.0%)</option>
				
				<option value="file1">github.com/heathcliff26/kube-upgrade/cmd/upgraded/main.go (0.0%)</option>
				
				<option value="file2">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/defaults.go (0.0%)</option>
				
				<option value="file3">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/register.go (83.3%)</option>
				
				<option value="file4">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file5">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/zz_generated.defaults.go (0.0%)</option>
				
				<option value="file6">github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/internal/internal.go (0.0%)</option>
				
				<option value="file7">github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/kubeupgrade/v1alpha1/kubeupgradeplan.go (0.0%)</option>
				
				<option value="file8">github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/kubeupgrade/v1alpha1/kubeupgradeplangroup.go (0.0%)</option>
				
				<option value="file9">github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/kubeupgrade/v1alpha1/kubeupgradespec.go (0.0%)</option>
				
				<option value="file10">github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/kubeupgrade/v1alpha1/kubeupgradestatus.go (0.0%)</option>
				
				<option value="file11">github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/utils.go (0.0%)</option>
				
				<option value="file12">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/clientset.go (0.0%)</option>
				
				<option value="file13">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/fake/clientset_generated.go (0.0%)</option>
				
				<option value="file14">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/fake/register.go (0.0%)</option>
				
				<option value="file15">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/scheme/register.go (100.0%)</option>
				
				<option value="file16">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1/fake/fake_kubeupgrade_client.go (0.0%)</option>
				
				<option value="file17">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1/fake/fake_kubeupgradeplan.go (0.0%)</option>
				
				<option value="file18">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1/kubeupgrade_client.go (0.0%)</option>
				
				<option value="file19">github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1/kubeupgradeplan.go (0.0%)</option>
				
				<option value="file20">github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/factory.go (0.0%)</option>
				
				<option value="file21">github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/generic.go (0.0%)</option>
				
				<option value="file22">github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/kubeupgrade/interface.go (0.0%)</option>
				
				<option value="file23">github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/kubeupgrade/v1alpha1/interface.go (0.0%)</option>
				
				<option value="file24">github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/kubeupgrade/v1alpha1/kubeupgradeplan.go (0.0%)</option>
				
				<option value="file25">github.com/heathcliff26/kube-upgrade/pkg/client/listers/kubeupgrade/v1alpha1/kubeupgradeplan.go (0.0%)</option>
				
				<option value="file26">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/controller.go (1.3%)</option>
				
				<option value="file27">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/errors.go (50.0%)</option>
				
				<option value="file28">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/utils.go (29.0%)</option>
				
				<option value="file29">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/root.go (23.5%)</option>
				
				<option value="file30">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/config.go (96.4%)</option>
				
				<option value="file31">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/errors.go (50.0%)</option>
				
				<option value="file32">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/daemon.go (0.0%)</option>
				
				<option value="file33">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/utils.go (0.0%)</option>
				
				<option value="file34">github.com/heathcliff26/kube-upgrade/pkg/upgraded/fleetlock/client.go (0.0%)</option>
				
				<option value="file35">github.com/heathcliff26/kube-upgrade/pkg/upgraded/fleetlock/utils.go (0.0%)</option>
				
				<option value="file36">github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm/kubeadm.go (0.0%)</option>
				
				<option value="file37">github.com/heathcliff26/kube-upgrade/pkg/upgraded/root.go (14.3%)</option>
				
				<option value="file38">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/rpm-ostree.go (0.0%)</option>
				
				<option value="file39">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/utils.go (0.0%)</option>
				
				<option value="file40">github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils/utils.go (0.0%)</option>
				
				<option value="file41">github.com/heathcliff26/kube-upgrade/pkg/version/version.go (73.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import controller "github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller"

func main() <span class="cov0" title="0">{
        controller.Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import upgraded "github.com/heathcliff26/kube-upgrade/pkg/upgraded"

func main() <span class="cov0" title="0">{
        upgraded.Execute()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package v1alpha1

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov0" title="0">{
        if spec.Groups == nil </span><span class="cov0" title="0">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                if group.Labels == nil </span><span class="cov0" title="0">{
                        group.Labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">spec.Groups[name] = group</span>
        }
}

func SetObjectDefaults_KubeUpgradeStatus(status *KubeUpgradeStatus) <span class="cov0" title="0">{
        if status.Summary == "" </span><span class="cov0" title="0">{
                status.Summary = "Unknown"
        }</span>
        <span class="cov0" title="0">if status.Groups == nil </span><span class="cov0" title="0">{
                status.Groups = make(map[string]string)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha1",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov8" title="1">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(addKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by deepcopy-gen. DO NOT EDIT.

package v1alpha1

import (
        runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KubeUpgradePlan) DeepCopyInto(out *KubeUpgradePlan) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
        return
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeUpgradePlan.
func (in *KubeUpgradePlan) DeepCopy() *KubeUpgradePlan <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(KubeUpgradePlan)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KubeUpgradePlan) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KubeUpgradePlanGroup) DeepCopyInto(out *KubeUpgradePlanGroup) <span class="cov0" title="0">{
        *out = *in
        if in.DependsOn != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DependsOn, &amp;out.DependsOn
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.Labels != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Labels, &amp;out.Labels
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeUpgradePlanGroup.
func (in *KubeUpgradePlanGroup) DeepCopy() *KubeUpgradePlanGroup <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(KubeUpgradePlanGroup)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KubeUpgradePlanList) DeepCopyInto(out *KubeUpgradePlanList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]KubeUpgradePlan, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeUpgradePlanList.
func (in *KubeUpgradePlanList) DeepCopy() *KubeUpgradePlanList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(KubeUpgradePlanList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KubeUpgradePlanList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KubeUpgradeSpec) DeepCopyInto(out *KubeUpgradeSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Groups != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Groups, &amp;out.Groups
                *out = make(map[string]KubeUpgradePlanGroup, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = *val.DeepCopy()
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeUpgradeSpec.
func (in *KubeUpgradeSpec) DeepCopy() *KubeUpgradeSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(KubeUpgradeSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KubeUpgradeStatus) DeepCopyInto(out *KubeUpgradeStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Groups != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Groups, &amp;out.Groups
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeUpgradeStatus.
func (in *KubeUpgradeStatus) DeepCopy() *KubeUpgradeStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(KubeUpgradeStatus)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by defaulter-gen. DO NOT EDIT.

package v1alpha1

import (
        runtime "k8s.io/apimachinery/pkg/runtime"
)

// RegisterDefaults adds defaulters functions to the given scheme.
// Public to allow building arbitrary schemes.
// All generated defaulters are covering - they call all nested defaulters.
func RegisterDefaults(scheme *runtime.Scheme) error <span class="cov0" title="0">{
        scheme.AddTypeDefaultingFunc(&amp;KubeUpgradePlan{}, func(obj interface{}) </span><span class="cov0" title="0">{ SetObjectDefaults_KubeUpgradePlan(obj.(*KubeUpgradePlan)) }</span>)
        <span class="cov0" title="0">scheme.AddTypeDefaultingFunc(&amp;KubeUpgradePlanList{}, func(obj interface{}) </span><span class="cov0" title="0">{ SetObjectDefaults_KubeUpgradePlanList(obj.(*KubeUpgradePlanList)) }</span>)
        <span class="cov0" title="0">return nil</span>
}

func SetObjectDefaults_KubeUpgradePlan(in *KubeUpgradePlan) <span class="cov0" title="0">{
        SetObjectDefaults_KubeUpgradeSpec(&amp;in.Spec)
        SetObjectDefaults_KubeUpgradeStatus(&amp;in.Status)
}</span>

func SetObjectDefaults_KubeUpgradePlanList(in *KubeUpgradePlanList) <span class="cov0" title="0">{
        for i := range in.Items </span><span class="cov0" title="0">{
                a := &amp;in.Items[i]
                SetObjectDefaults_KubeUpgradePlan(a)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by applyconfiguration-gen. DO NOT EDIT.

package internal

import (
        "fmt"
        "sync"

        typed "sigs.k8s.io/structured-merge-diff/v4/typed"
)

func Parser() *typed.Parser <span class="cov0" title="0">{
        parserOnce.Do(func() </span><span class="cov0" title="0">{
                var err error
                parser, err = typed.NewParser(schemaYAML)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to parse schema: %v", err))</span>
                }
        })
        <span class="cov0" title="0">return parser</span>
}

var parserOnce sync.Once
var parser *typed.Parser
var schemaYAML = typed.YAMLObject(`types:
- name: __untyped_atomic_
  scalar: untyped
  list:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
  map:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
- name: __untyped_deduced_
  scalar: untyped
  list:
    elementType:
      namedType: __untyped_atomic_
    elementRelationship: atomic
  map:
    elementType:
      namedType: __untyped_deduced_
    elementRelationship: separable
`)
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        v1 "k8s.io/client-go/applyconfigurations/meta/v1"
)

// KubeUpgradePlanApplyConfiguration represents a declarative configuration of the KubeUpgradePlan type for use
// with apply.
type KubeUpgradePlanApplyConfiguration struct {
        v1.TypeMetaApplyConfiguration    `json:",inline"`
        *v1.ObjectMetaApplyConfiguration `json:"metadata,omitempty"`
        Spec                             *KubeUpgradeSpecApplyConfiguration   `json:"spec,omitempty"`
        Status                           *KubeUpgradeStatusApplyConfiguration `json:"status,omitempty"`
}

// KubeUpgradePlan constructs a declarative configuration of the KubeUpgradePlan type for use with
// apply.
func KubeUpgradePlan(name, namespace string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b := &amp;KubeUpgradePlanApplyConfiguration{}
        b.WithName(name)
        b.WithNamespace(namespace)
        b.WithKind("KubeUpgradePlan")
        b.WithAPIVersion("kubeupgrade.heathcliff.eu/v1alpha1")
        return b
}</span>

// WithKind sets the Kind field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Kind field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithKind(value string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.Kind = &amp;value
        return b
}</span>

// WithAPIVersion sets the APIVersion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the APIVersion field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithAPIVersion(value string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.APIVersion = &amp;value
        return b
}</span>

// WithName sets the Name field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Name field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithName(value string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.Name = &amp;value
        return b
}</span>

// WithGenerateName sets the GenerateName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the GenerateName field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithGenerateName(value string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.GenerateName = &amp;value
        return b
}</span>

// WithNamespace sets the Namespace field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Namespace field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithNamespace(value string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.Namespace = &amp;value
        return b
}</span>

// WithUID sets the UID field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UID field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithUID(value types.UID) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.UID = &amp;value
        return b
}</span>

// WithResourceVersion sets the ResourceVersion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ResourceVersion field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithResourceVersion(value string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.ResourceVersion = &amp;value
        return b
}</span>

// WithGeneration sets the Generation field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Generation field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithGeneration(value int64) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.Generation = &amp;value
        return b
}</span>

// WithCreationTimestamp sets the CreationTimestamp field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the CreationTimestamp field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithCreationTimestamp(value metav1.Time) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.CreationTimestamp = &amp;value
        return b
}</span>

// WithDeletionTimestamp sets the DeletionTimestamp field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DeletionTimestamp field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithDeletionTimestamp(value metav1.Time) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.DeletionTimestamp = &amp;value
        return b
}</span>

// WithDeletionGracePeriodSeconds sets the DeletionGracePeriodSeconds field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DeletionGracePeriodSeconds field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithDeletionGracePeriodSeconds(value int64) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        b.DeletionGracePeriodSeconds = &amp;value
        return b
}</span>

// WithLabels puts the entries into the Labels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Labels field,
// overwriting an existing map entries in Labels field with the same key.
func (b *KubeUpgradePlanApplyConfiguration) WithLabels(entries map[string]string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        if b.Labels == nil &amp;&amp; len(entries) &gt; 0 </span><span class="cov0" title="0">{
                b.Labels = make(map[string]string, len(entries))
        }</span>
        <span class="cov0" title="0">for k, v := range entries </span><span class="cov0" title="0">{
                b.Labels[k] = v
        }</span>
        <span class="cov0" title="0">return b</span>
}

// WithAnnotations puts the entries into the Annotations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Annotations field,
// overwriting an existing map entries in Annotations field with the same key.
func (b *KubeUpgradePlanApplyConfiguration) WithAnnotations(entries map[string]string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        if b.Annotations == nil &amp;&amp; len(entries) &gt; 0 </span><span class="cov0" title="0">{
                b.Annotations = make(map[string]string, len(entries))
        }</span>
        <span class="cov0" title="0">for k, v := range entries </span><span class="cov0" title="0">{
                b.Annotations[k] = v
        }</span>
        <span class="cov0" title="0">return b</span>
}

// WithOwnerReferences adds the given value to the OwnerReferences field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the OwnerReferences field.
func (b *KubeUpgradePlanApplyConfiguration) WithOwnerReferences(values ...*v1.OwnerReferenceApplyConfiguration) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        for i := range values </span><span class="cov0" title="0">{
                if values[i] == nil </span><span class="cov0" title="0">{
                        panic("nil value passed to WithOwnerReferences")</span>
                }
                <span class="cov0" title="0">b.OwnerReferences = append(b.OwnerReferences, *values[i])</span>
        }
        <span class="cov0" title="0">return b</span>
}

// WithFinalizers adds the given value to the Finalizers field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Finalizers field.
func (b *KubeUpgradePlanApplyConfiguration) WithFinalizers(values ...string) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        for i := range values </span><span class="cov0" title="0">{
                b.Finalizers = append(b.Finalizers, values[i])
        }</span>
        <span class="cov0" title="0">return b</span>
}

func (b *KubeUpgradePlanApplyConfiguration) ensureObjectMetaApplyConfigurationExists() <span class="cov0" title="0">{
        if b.ObjectMetaApplyConfiguration == nil </span><span class="cov0" title="0">{
                b.ObjectMetaApplyConfiguration = &amp;v1.ObjectMetaApplyConfiguration{}
        }</span>
}

// WithSpec sets the Spec field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Spec field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithSpec(value *KubeUpgradeSpecApplyConfiguration) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.Spec = value
        return b
}</span>

// WithStatus sets the Status field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Status field is set to the value of the last call.
func (b *KubeUpgradePlanApplyConfiguration) WithStatus(value *KubeUpgradeStatusApplyConfiguration) *KubeUpgradePlanApplyConfiguration <span class="cov0" title="0">{
        b.Status = value
        return b
}</span>

// GetName retrieves the value of the Name field in the declarative configuration.
func (b *KubeUpgradePlanApplyConfiguration) GetName() *string <span class="cov0" title="0">{
        b.ensureObjectMetaApplyConfigurationExists()
        return b.Name
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

// KubeUpgradePlanGroupApplyConfiguration represents a declarative configuration of the KubeUpgradePlanGroup type for use
// with apply.
type KubeUpgradePlanGroupApplyConfiguration struct {
        DependsOn []string          `json:"dependsOn,omitempty"`
        Labels    map[string]string `json:"labels,omitempty"`
}

// KubeUpgradePlanGroupApplyConfiguration constructs a declarative configuration of the KubeUpgradePlanGroup type for use with
// apply.
func KubeUpgradePlanGroup() *KubeUpgradePlanGroupApplyConfiguration <span class="cov0" title="0">{
        return &amp;KubeUpgradePlanGroupApplyConfiguration{}
}</span>

// WithDependsOn adds the given value to the DependsOn field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the DependsOn field.
func (b *KubeUpgradePlanGroupApplyConfiguration) WithDependsOn(values ...string) *KubeUpgradePlanGroupApplyConfiguration <span class="cov0" title="0">{
        for i := range values </span><span class="cov0" title="0">{
                b.DependsOn = append(b.DependsOn, values[i])
        }</span>
        <span class="cov0" title="0">return b</span>
}

// WithLabels puts the entries into the Labels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Labels field,
// overwriting an existing map entries in Labels field with the same key.
func (b *KubeUpgradePlanGroupApplyConfiguration) WithLabels(entries map[string]string) *KubeUpgradePlanGroupApplyConfiguration <span class="cov0" title="0">{
        if b.Labels == nil &amp;&amp; len(entries) &gt; 0 </span><span class="cov0" title="0">{
                b.Labels = make(map[string]string, len(entries))
        }</span>
        <span class="cov0" title="0">for k, v := range entries </span><span class="cov0" title="0">{
                b.Labels[k] = v
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

// KubeUpgradeSpecApplyConfiguration represents a declarative configuration of the KubeUpgradeSpec type for use
// with apply.
type KubeUpgradeSpecApplyConfiguration struct {
        KubernetesVersion *string                                           `json:"kubernetesVersion,omitempty"`
        Groups            map[string]KubeUpgradePlanGroupApplyConfiguration `json:"groups,omitempty"`
}

// KubeUpgradeSpecApplyConfiguration constructs a declarative configuration of the KubeUpgradeSpec type for use with
// apply.
func KubeUpgradeSpec() *KubeUpgradeSpecApplyConfiguration <span class="cov0" title="0">{
        return &amp;KubeUpgradeSpecApplyConfiguration{}
}</span>

// WithKubernetesVersion sets the KubernetesVersion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the KubernetesVersion field is set to the value of the last call.
func (b *KubeUpgradeSpecApplyConfiguration) WithKubernetesVersion(value string) *KubeUpgradeSpecApplyConfiguration <span class="cov0" title="0">{
        b.KubernetesVersion = &amp;value
        return b
}</span>

// WithGroups puts the entries into the Groups field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Groups field,
// overwriting an existing map entries in Groups field with the same key.
func (b *KubeUpgradeSpecApplyConfiguration) WithGroups(entries map[string]KubeUpgradePlanGroupApplyConfiguration) *KubeUpgradeSpecApplyConfiguration <span class="cov0" title="0">{
        if b.Groups == nil &amp;&amp; len(entries) &gt; 0 </span><span class="cov0" title="0">{
                b.Groups = make(map[string]KubeUpgradePlanGroupApplyConfiguration, len(entries))
        }</span>
        <span class="cov0" title="0">for k, v := range entries </span><span class="cov0" title="0">{
                b.Groups[k] = v
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

// KubeUpgradeStatusApplyConfiguration represents a declarative configuration of the KubeUpgradeStatus type for use
// with apply.
type KubeUpgradeStatusApplyConfiguration struct {
        Summary *string           `json:"summary,omitempty"`
        Groups  map[string]string `json:"groups,omitempty"`
}

// KubeUpgradeStatusApplyConfiguration constructs a declarative configuration of the KubeUpgradeStatus type for use with
// apply.
func KubeUpgradeStatus() *KubeUpgradeStatusApplyConfiguration <span class="cov0" title="0">{
        return &amp;KubeUpgradeStatusApplyConfiguration{}
}</span>

// WithSummary sets the Summary field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Summary field is set to the value of the last call.
func (b *KubeUpgradeStatusApplyConfiguration) WithSummary(value string) *KubeUpgradeStatusApplyConfiguration <span class="cov0" title="0">{
        b.Summary = &amp;value
        return b
}</span>

// WithGroups puts the entries into the Groups field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Groups field,
// overwriting an existing map entries in Groups field with the same key.
func (b *KubeUpgradeStatusApplyConfiguration) WithGroups(entries map[string]string) *KubeUpgradeStatusApplyConfiguration <span class="cov0" title="0">{
        if b.Groups == nil &amp;&amp; len(entries) &gt; 0 </span><span class="cov0" title="0">{
                b.Groups = make(map[string]string, len(entries))
        }</span>
        <span class="cov0" title="0">for k, v := range entries </span><span class="cov0" title="0">{
                b.Groups[k] = v
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by applyconfiguration-gen. DO NOT EDIT.

package applyconfiguration

import (
        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        internal "github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/internal"
        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/kubeupgrade/v1alpha1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        testing "k8s.io/client-go/testing"
)

// ForKind returns an apply configuration type for the given GroupVersionKind, or nil if no
// apply configuration type exists for the given GroupVersionKind.
func ForKind(kind schema.GroupVersionKind) interface{} <span class="cov0" title="0">{
        switch kind </span>{
        // Group=kubeupgrade.heathcliff.eu, Version=v1alpha1
        case v1alpha1.SchemeGroupVersion.WithKind("KubeUpgradePlan"):<span class="cov0" title="0">
                return &amp;kubeupgradev1alpha1.KubeUpgradePlanApplyConfiguration{}</span>
        case v1alpha1.SchemeGroupVersion.WithKind("KubeUpgradePlanGroup"):<span class="cov0" title="0">
                return &amp;kubeupgradev1alpha1.KubeUpgradePlanGroupApplyConfiguration{}</span>
        case v1alpha1.SchemeGroupVersion.WithKind("KubeUpgradeSpec"):<span class="cov0" title="0">
                return &amp;kubeupgradev1alpha1.KubeUpgradeSpecApplyConfiguration{}</span>
        case v1alpha1.SchemeGroupVersion.WithKind("KubeUpgradeStatus"):<span class="cov0" title="0">
                return &amp;kubeupgradev1alpha1.KubeUpgradeStatusApplyConfiguration{}</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func NewTypeConverter(scheme *runtime.Scheme) *testing.TypeConverter <span class="cov0" title="0">{
        return &amp;testing.TypeConverter{Scheme: scheme, TypeResolver: internal.Parser()}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package versioned

import (
        "fmt"
        "net/http"

        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1"
        discovery "k8s.io/client-go/discovery"
        rest "k8s.io/client-go/rest"
        flowcontrol "k8s.io/client-go/util/flowcontrol"
)

type Interface interface {
        Discovery() discovery.DiscoveryInterface
        KubeupgradeV1alpha1() kubeupgradev1alpha1.KubeupgradeV1alpha1Interface
}

// Clientset contains the clients for groups.
type Clientset struct {
        *discovery.DiscoveryClient
        kubeupgradeV1alpha1 *kubeupgradev1alpha1.KubeupgradeV1alpha1Client
}

// KubeupgradeV1alpha1 retrieves the KubeupgradeV1alpha1Client
func (c *Clientset) KubeupgradeV1alpha1() kubeupgradev1alpha1.KubeupgradeV1alpha1Interface <span class="cov0" title="0">{
        return c.kubeupgradeV1alpha1
}</span>

// Discovery retrieves the DiscoveryClient
func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.DiscoveryClient</span>
}

// NewForConfig creates a new Clientset for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfig will generate a rate-limiter in configShallowCopy.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c

        if configShallowCopy.UserAgent == "" </span><span class="cov0" title="0">{
                configShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        // share the transport between all clients
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span>
}

// NewForConfigAndClient creates a new Clientset for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfigAndClient will generate a rate-limiter in configShallowCopy.
func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c
        if configShallowCopy.RateLimiter == nil &amp;&amp; configShallowCopy.QPS &gt; 0 </span><span class="cov0" title="0">{
                if configShallowCopy.Burst &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0")
                }</span>
                <span class="cov0" title="0">configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)</span>
        }

        <span class="cov0" title="0">var cs Clientset
        var err error
        cs.kubeupgradeV1alpha1, err = kubeupgradev1alpha1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cs, nil</span>
}

// NewForConfigOrDie creates a new Clientset for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *Clientset <span class="cov0" title="0">{
        cs, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cs</span>
}

// New creates a new Clientset for the given RESTClient.
func New(c rest.Interface) *Clientset <span class="cov0" title="0">{
        var cs Clientset
        cs.kubeupgradeV1alpha1 = kubeupgradev1alpha1.New(c)

        cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
        return &amp;cs
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        applyconfiguration "github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration"
        clientset "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned"
        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1"
        fakekubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1/fake"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/discovery"
        fakediscovery "k8s.io/client-go/discovery/fake"
        "k8s.io/client-go/testing"
)

// NewSimpleClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any field management, validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
//
// DEPRECATED: NewClientset replaces this with support for field management, which significantly improves
// server side apply testing. NewClientset is only available when apply configurations are generated (e.g.
// via --with-applyconfig).
func NewSimpleClientset(objects ...runtime.Object) *Clientset <span class="cov0" title="0">{
        o := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())
        for _, obj := range objects </span><span class="cov0" title="0">{
                if err := o.Add(obj); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">cs := &amp;Clientset{tracker: o}
        cs.discovery = &amp;fakediscovery.FakeDiscovery{Fake: &amp;cs.Fake}
        cs.AddReactor("*", "*", testing.ObjectReaction(o))
        cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) </span><span class="cov0" title="0">{
                gvr := action.GetResource()
                ns := action.GetNamespace()
                watch, err := o.Watch(gvr, ns)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">return true, watch, nil</span>
        })

        <span class="cov0" title="0">return cs</span>
}

// Clientset implements clientset.Interface. Meant to be embedded into a
// struct to get a default implementation. This makes faking out just the method
// you want to test easier.
type Clientset struct {
        testing.Fake
        discovery *fakediscovery.FakeDiscovery
        tracker   testing.ObjectTracker
}

func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        return c.discovery
}</span>

func (c *Clientset) Tracker() testing.ObjectTracker <span class="cov0" title="0">{
        return c.tracker
}</span>

// NewClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
func NewClientset(objects ...runtime.Object) *Clientset <span class="cov0" title="0">{
        o := testing.NewFieldManagedObjectTracker(
                scheme,
                codecs.UniversalDecoder(),
                applyconfiguration.NewTypeConverter(scheme),
        )
        for _, obj := range objects </span><span class="cov0" title="0">{
                if err := o.Add(obj); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">cs := &amp;Clientset{tracker: o}
        cs.discovery = &amp;fakediscovery.FakeDiscovery{Fake: &amp;cs.Fake}
        cs.AddReactor("*", "*", testing.ObjectReaction(o))
        cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) </span><span class="cov0" title="0">{
                gvr := action.GetResource()
                ns := action.GetNamespace()
                watch, err := o.Watch(gvr, ns)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">return true, watch, nil</span>
        })

        <span class="cov0" title="0">return cs</span>
}

var (
        _ clientset.Interface = &amp;Clientset{}
        _ testing.FakeClient  = &amp;Clientset{}
)

// KubeupgradeV1alpha1 retrieves the KubeupgradeV1alpha1Client
func (c *Clientset) KubeupgradeV1alpha1() kubeupgradev1alpha1.KubeupgradeV1alpha1Interface <span class="cov0" title="0">{
        return &amp;fakekubeupgradev1alpha1.FakeKubeupgradeV1alpha1{Fake: &amp;c.Fake}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var scheme = runtime.NewScheme()
var codecs = serializer.NewCodecFactory(scheme)

var localSchemeBuilder = runtime.SchemeBuilder{
        kubeupgradev1alpha1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(scheme))
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package scheme

import (
        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var Scheme = runtime.NewScheme()
var Codecs = serializer.NewCodecFactory(Scheme)
var ParameterCodec = runtime.NewParameterCodec(Scheme)
var localSchemeBuilder = runtime.SchemeBuilder{
        kubeupgradev1alpha1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov8" title="1">{
        v1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(Scheme))
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/typed/kubeupgrade/v1alpha1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeKubeupgradeV1alpha1 struct {
        *testing.Fake
}

func (c *FakeKubeupgradeV1alpha1) KubeUpgradePlans(namespace string) v1alpha1.KubeUpgradePlanInterface <span class="cov0" title="0">{
        return &amp;FakeKubeUpgradePlans{c, namespace}
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeKubeupgradeV1alpha1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        "context"
        json "encoding/json"
        "fmt"

        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/kubeupgrade/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        testing "k8s.io/client-go/testing"
)

// FakeKubeUpgradePlans implements KubeUpgradePlanInterface
type FakeKubeUpgradePlans struct {
        Fake *FakeKubeupgradeV1alpha1
        ns   string
}

var kubeupgradeplansResource = v1alpha1.SchemeGroupVersion.WithResource("kubeupgradeplans")

var kubeupgradeplansKind = v1alpha1.SchemeGroupVersion.WithKind("KubeUpgradePlan")

// Get takes name of the kubeUpgradePlan, and returns the corresponding kubeUpgradePlan object, and an error if there is any.
func (c *FakeKubeUpgradePlans) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.KubeUpgradePlan, err error) <span class="cov0" title="0">{
        emptyResult := &amp;v1alpha1.KubeUpgradePlan{}
        obj, err := c.Fake.
                Invokes(testing.NewGetActionWithOptions(kubeupgradeplansResource, c.ns, name, options), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>
        <span class="cov0" title="0">return obj.(*v1alpha1.KubeUpgradePlan), err</span>
}

// List takes label and field selectors, and returns the list of KubeUpgradePlans that match those selectors.
func (c *FakeKubeUpgradePlans) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.KubeUpgradePlanList, err error) <span class="cov0" title="0">{
        emptyResult := &amp;v1alpha1.KubeUpgradePlanList{}
        obj, err := c.Fake.
                Invokes(testing.NewListActionWithOptions(kubeupgradeplansResource, kubeupgradeplansKind, c.ns, opts), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>

        <span class="cov0" title="0">label, _, _ := testing.ExtractFromListOptions(opts)
        if label == nil </span><span class="cov0" title="0">{
                label = labels.Everything()
        }</span>
        <span class="cov0" title="0">list := &amp;v1alpha1.KubeUpgradePlanList{ListMeta: obj.(*v1alpha1.KubeUpgradePlanList).ListMeta}
        for _, item := range obj.(*v1alpha1.KubeUpgradePlanList).Items </span><span class="cov0" title="0">{
                if label.Matches(labels.Set(item.Labels)) </span><span class="cov0" title="0">{
                        list.Items = append(list.Items, item)
                }</span>
        }
        <span class="cov0" title="0">return list, err</span>
}

// Watch returns a watch.Interface that watches the requested kubeUpgradePlans.
func (c *FakeKubeUpgradePlans) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        return c.Fake.
                InvokesWatch(testing.NewWatchActionWithOptions(kubeupgradeplansResource, c.ns, opts))

}</span>

// Create takes the representation of a kubeUpgradePlan and creates it.  Returns the server's representation of the kubeUpgradePlan, and an error, if there is any.
func (c *FakeKubeUpgradePlans) Create(ctx context.Context, kubeUpgradePlan *v1alpha1.KubeUpgradePlan, opts v1.CreateOptions) (result *v1alpha1.KubeUpgradePlan, err error) <span class="cov0" title="0">{
        emptyResult := &amp;v1alpha1.KubeUpgradePlan{}
        obj, err := c.Fake.
                Invokes(testing.NewCreateActionWithOptions(kubeupgradeplansResource, c.ns, kubeUpgradePlan, opts), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>
        <span class="cov0" title="0">return obj.(*v1alpha1.KubeUpgradePlan), err</span>
}

// Update takes the representation of a kubeUpgradePlan and updates it. Returns the server's representation of the kubeUpgradePlan, and an error, if there is any.
func (c *FakeKubeUpgradePlans) Update(ctx context.Context, kubeUpgradePlan *v1alpha1.KubeUpgradePlan, opts v1.UpdateOptions) (result *v1alpha1.KubeUpgradePlan, err error) <span class="cov0" title="0">{
        emptyResult := &amp;v1alpha1.KubeUpgradePlan{}
        obj, err := c.Fake.
                Invokes(testing.NewUpdateActionWithOptions(kubeupgradeplansResource, c.ns, kubeUpgradePlan, opts), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>
        <span class="cov0" title="0">return obj.(*v1alpha1.KubeUpgradePlan), err</span>
}

// UpdateStatus was generated because the type contains a Status member.
// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
func (c *FakeKubeUpgradePlans) UpdateStatus(ctx context.Context, kubeUpgradePlan *v1alpha1.KubeUpgradePlan, opts v1.UpdateOptions) (result *v1alpha1.KubeUpgradePlan, err error) <span class="cov0" title="0">{
        emptyResult := &amp;v1alpha1.KubeUpgradePlan{}
        obj, err := c.Fake.
                Invokes(testing.NewUpdateSubresourceActionWithOptions(kubeupgradeplansResource, "status", c.ns, kubeUpgradePlan, opts), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>
        <span class="cov0" title="0">return obj.(*v1alpha1.KubeUpgradePlan), err</span>
}

// Delete takes name of the kubeUpgradePlan and deletes it. Returns an error if one occurs.
func (c *FakeKubeUpgradePlans) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error <span class="cov0" title="0">{
        _, err := c.Fake.
                Invokes(testing.NewDeleteActionWithOptions(kubeupgradeplansResource, c.ns, name, opts), &amp;v1alpha1.KubeUpgradePlan{})

        return err
}</span>

// DeleteCollection deletes a collection of objects.
func (c *FakeKubeUpgradePlans) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error <span class="cov0" title="0">{
        action := testing.NewDeleteCollectionActionWithOptions(kubeupgradeplansResource, c.ns, opts, listOpts)

        _, err := c.Fake.Invokes(action, &amp;v1alpha1.KubeUpgradePlanList{})
        return err
}</span>

// Patch applies the patch and returns the patched kubeUpgradePlan.
func (c *FakeKubeUpgradePlans) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.KubeUpgradePlan, err error) <span class="cov0" title="0">{
        emptyResult := &amp;v1alpha1.KubeUpgradePlan{}
        obj, err := c.Fake.
                Invokes(testing.NewPatchSubresourceActionWithOptions(kubeupgradeplansResource, c.ns, name, pt, data, opts, subresources...), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>
        <span class="cov0" title="0">return obj.(*v1alpha1.KubeUpgradePlan), err</span>
}

// Apply takes the given apply declarative configuration, applies it and returns the applied kubeUpgradePlan.
func (c *FakeKubeUpgradePlans) Apply(ctx context.Context, kubeUpgradePlan *kubeupgradev1alpha1.KubeUpgradePlanApplyConfiguration, opts v1.ApplyOptions) (result *v1alpha1.KubeUpgradePlan, err error) <span class="cov0" title="0">{
        if kubeUpgradePlan == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kubeUpgradePlan provided to Apply must not be nil")
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(kubeUpgradePlan)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">name := kubeUpgradePlan.Name
        if name == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kubeUpgradePlan.Name must be provided to Apply")
        }</span>
        <span class="cov0" title="0">emptyResult := &amp;v1alpha1.KubeUpgradePlan{}
        obj, err := c.Fake.
                Invokes(testing.NewPatchSubresourceActionWithOptions(kubeupgradeplansResource, c.ns, *name, types.ApplyPatchType, data, opts.ToPatchOptions()), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>
        <span class="cov0" title="0">return obj.(*v1alpha1.KubeUpgradePlan), err</span>
}

// ApplyStatus was generated because the type contains a Status member.
// Add a +genclient:noStatus comment above the type to avoid generating ApplyStatus().
func (c *FakeKubeUpgradePlans) ApplyStatus(ctx context.Context, kubeUpgradePlan *kubeupgradev1alpha1.KubeUpgradePlanApplyConfiguration, opts v1.ApplyOptions) (result *v1alpha1.KubeUpgradePlan, err error) <span class="cov0" title="0">{
        if kubeUpgradePlan == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kubeUpgradePlan provided to Apply must not be nil")
        }</span>
        <span class="cov0" title="0">data, err := json.Marshal(kubeUpgradePlan)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">name := kubeUpgradePlan.Name
        if name == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kubeUpgradePlan.Name must be provided to Apply")
        }</span>
        <span class="cov0" title="0">emptyResult := &amp;v1alpha1.KubeUpgradePlan{}
        obj, err := c.Fake.
                Invokes(testing.NewPatchSubresourceActionWithOptions(kubeupgradeplansResource, c.ns, *name, types.ApplyPatchType, data, opts.ToPatchOptions(), "status"), emptyResult)

        if obj == nil </span><span class="cov0" title="0">{
                return emptyResult, err
        }</span>
        <span class="cov0" title="0">return obj.(*v1alpha1.KubeUpgradePlan), err</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        "net/http"

        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type KubeupgradeV1alpha1Interface interface {
        RESTClient() rest.Interface
        KubeUpgradePlansGetter
}

// KubeupgradeV1alpha1Client is used to interact with features provided by the kubeupgrade.heathcliff.eu group.
type KubeupgradeV1alpha1Client struct {
        restClient rest.Interface
}

func (c *KubeupgradeV1alpha1Client) KubeUpgradePlans(namespace string) KubeUpgradePlanInterface <span class="cov0" title="0">{
        return newKubeUpgradePlans(c, namespace)
}</span>

// NewForConfig creates a new KubeupgradeV1alpha1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*KubeupgradeV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new KubeupgradeV1alpha1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*KubeupgradeV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;KubeupgradeV1alpha1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new KubeupgradeV1alpha1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *KubeupgradeV1alpha1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new KubeupgradeV1alpha1Client for the given RESTClient.
func New(c rest.Interface) *KubeupgradeV1alpha1Client <span class="cov0" title="0">{
        return &amp;KubeupgradeV1alpha1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := v1alpha1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = scheme.Codecs.WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *KubeupgradeV1alpha1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        "context"

        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/applyconfiguration/kubeupgrade/v1alpha1"
        scheme "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// KubeUpgradePlansGetter has a method to return a KubeUpgradePlanInterface.
// A group's client should implement this interface.
type KubeUpgradePlansGetter interface {
        KubeUpgradePlans(namespace string) KubeUpgradePlanInterface
}

// KubeUpgradePlanInterface has methods to work with KubeUpgradePlan resources.
type KubeUpgradePlanInterface interface {
        Create(ctx context.Context, kubeUpgradePlan *v1alpha1.KubeUpgradePlan, opts v1.CreateOptions) (*v1alpha1.KubeUpgradePlan, error)
        Update(ctx context.Context, kubeUpgradePlan *v1alpha1.KubeUpgradePlan, opts v1.UpdateOptions) (*v1alpha1.KubeUpgradePlan, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, kubeUpgradePlan *v1alpha1.KubeUpgradePlan, opts v1.UpdateOptions) (*v1alpha1.KubeUpgradePlan, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.KubeUpgradePlan, error)
        List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.KubeUpgradePlanList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.KubeUpgradePlan, err error)
        Apply(ctx context.Context, kubeUpgradePlan *kubeupgradev1alpha1.KubeUpgradePlanApplyConfiguration, opts v1.ApplyOptions) (result *v1alpha1.KubeUpgradePlan, err error)
        // Add a +genclient:noStatus comment above the type to avoid generating ApplyStatus().
        ApplyStatus(ctx context.Context, kubeUpgradePlan *kubeupgradev1alpha1.KubeUpgradePlanApplyConfiguration, opts v1.ApplyOptions) (result *v1alpha1.KubeUpgradePlan, err error)
        KubeUpgradePlanExpansion
}

// kubeUpgradePlans implements KubeUpgradePlanInterface
type kubeUpgradePlans struct {
        *gentype.ClientWithListAndApply[*v1alpha1.KubeUpgradePlan, *v1alpha1.KubeUpgradePlanList, *kubeupgradev1alpha1.KubeUpgradePlanApplyConfiguration]
}

// newKubeUpgradePlans returns a KubeUpgradePlans
func newKubeUpgradePlans(c *KubeupgradeV1alpha1Client, namespace string) *kubeUpgradePlans <span class="cov0" title="0">{
        return &amp;kubeUpgradePlans{
                gentype.NewClientWithListAndApply[*v1alpha1.KubeUpgradePlan, *v1alpha1.KubeUpgradePlanList, *kubeupgradev1alpha1.KubeUpgradePlanApplyConfiguration](
                        "kubeupgradeplans",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *v1alpha1.KubeUpgradePlan </span><span class="cov0" title="0">{ return &amp;v1alpha1.KubeUpgradePlan{} }</span>,
                        func() *v1alpha1.KubeUpgradePlanList <span class="cov0" title="0">{ return &amp;v1alpha1.KubeUpgradePlanList{} }</span>),
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        reflect "reflect"
        sync "sync"
        time "time"

        versioned "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned"
        internalinterfaces "github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/internalinterfaces"
        kubeupgrade "github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/kubeupgrade"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
        client           versioned.Interface
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        lock             sync.Mutex
        defaultResync    time.Duration
        customResync     map[reflect.Type]time.Duration
        transform        cache.TransformFunc

        informers map[reflect.Type]cache.SharedIndexInformer
        // startedInformers is used for tracking which informers have been started.
        // This allows Start() to be called multiple times safely.
        startedInformers map[reflect.Type]bool
        // wg tracks how many goroutines were started.
        wg sync.WaitGroup
        // shuttingDown is true when Shutdown has been called. It may still be running
        // because it needs to wait for goroutines.
        shuttingDown bool
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                for k, v := range resyncConfig </span><span class="cov0" title="0">{
                        factory.customResync[reflect.TypeOf(k)] = v
                }</span>
                <span class="cov0" title="0">return factory</span>
        }
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.tweakListOptions = tweakListOptions
                return factory
        }</span>
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.namespace = namespace
                return factory
        }</span>
}

// WithTransform sets a transform on all informers.
func WithTransform(transform cache.TransformFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.transform = transform
                return factory
        }</span>
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client versioned.Interface, defaultResync time.Duration) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync)
}</span>

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client versioned.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}</span>

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client versioned.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory <span class="cov0" title="0">{
        factory := &amp;sharedInformerFactory{
                client:           client,
                namespace:        v1.NamespaceAll,
                defaultResync:    defaultResync,
                informers:        make(map[reflect.Type]cache.SharedIndexInformer),
                startedInformers: make(map[reflect.Type]bool),
                customResync:     make(map[reflect.Type]time.Duration),
        }

        // Apply all options
        for _, opt := range options </span><span class="cov0" title="0">{
                factory = opt(factory)
        }</span>

        <span class="cov0" title="0">return factory</span>
}

func (f *sharedInformerFactory) Start(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        if f.shuttingDown </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                if !f.startedInformers[informerType] </span><span class="cov0" title="0">{
                        f.wg.Add(1)
                        // We need a new variable in each loop iteration,
                        // otherwise the goroutine would use the loop variable
                        // and that keeps changing.
                        informer := informer
                        go func() </span><span class="cov0" title="0">{
                                defer f.wg.Done()
                                informer.Run(stopCh)
                        }</span>()
                        <span class="cov0" title="0">f.startedInformers[informerType] = true</span>
                }
        }
}

func (f *sharedInformerFactory) Shutdown() <span class="cov0" title="0">{
        f.lock.Lock()
        f.shuttingDown = true
        f.lock.Unlock()

        // Will return immediately if there is nothing to wait for.
        f.wg.Wait()
}</span>

func (f *sharedInformerFactory) WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool <span class="cov0" title="0">{
        informers := func() map[reflect.Type]cache.SharedIndexInformer </span><span class="cov0" title="0">{
                f.lock.Lock()
                defer f.lock.Unlock()

                informers := map[reflect.Type]cache.SharedIndexInformer{}
                for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                        if f.startedInformers[informerType] </span><span class="cov0" title="0">{
                                informers[informerType] = informer
                        }</span>
                }
                <span class="cov0" title="0">return informers</span>
        }()

        <span class="cov0" title="0">res := map[reflect.Type]bool{}
        for informType, informer := range informers </span><span class="cov0" title="0">{
                res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
        }</span>
        <span class="cov0" title="0">return res</span>
}

// InformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        informerType := reflect.TypeOf(obj)
        informer, exists := f.informers[informerType]
        if exists </span><span class="cov0" title="0">{
                return informer
        }</span>

        <span class="cov0" title="0">resyncPeriod, exists := f.customResync[informerType]
        if !exists </span><span class="cov0" title="0">{
                resyncPeriod = f.defaultResync
        }</span>

        <span class="cov0" title="0">informer = newFunc(f.client, resyncPeriod)
        informer.SetTransform(f.transform)
        f.informers[informerType] = informer

        return informer</span>
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
//
// It is typically used like this:
//
//        ctx, cancel := context.Background()
//        defer cancel()
//        factory := NewSharedInformerFactory(client, resyncPeriod)
//        defer factory.WaitForStop()    // Returns immediately if nothing was started.
//        genericInformer := factory.ForResource(resource)
//        typedInformer := factory.SomeAPIGroup().V1().SomeType()
//        factory.Start(ctx.Done())          // Start processing these informers.
//        synced := factory.WaitForCacheSync(ctx.Done())
//        for v, ok := range synced {
//            if !ok {
//                fmt.Fprintf(os.Stderr, "caches failed to sync: %v", v)
//                return
//            }
//        }
//
//        // Creating informers can also be created after Start, but then
//        // Start must be called again:
//        anotherGenericInformer := factory.ForResource(resource)
//        factory.Start(ctx.Done())
type SharedInformerFactory interface {
        internalinterfaces.SharedInformerFactory

        // Start initializes all requested informers. They are handled in goroutines
        // which run until the stop channel gets closed.
        // Warning: Start does not block. When run in a go-routine, it will race with a later WaitForCacheSync.
        Start(stopCh &lt;-chan struct{})

        // Shutdown marks a factory as shutting down. At that point no new
        // informers can be started anymore and Start will return without
        // doing anything.
        //
        // In addition, Shutdown blocks until all goroutines have terminated. For that
        // to happen, the close channel(s) that they were started with must be closed,
        // either before Shutdown gets called or while it is waiting.
        //
        // Shutdown may be called multiple times, even concurrently. All such calls will
        // block until all goroutines have terminated.
        Shutdown()

        // WaitForCacheSync blocks until all started informers' caches were synced
        // or the stop channel gets closed.
        WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

        // ForResource gives generic access to a shared informer of the matching type.
        ForResource(resource schema.GroupVersionResource) (GenericInformer, error)

        // InformerFor returns the SharedIndexInformer for obj using an internal
        // client.
        InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer

        Kubeupgrade() kubeupgrade.Interface
}

func (f *sharedInformerFactory) Kubeupgrade() kubeupgrade.Interface <span class="cov0" title="0">{
        return kubeupgrade.New(f, f.namespace, f.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        "fmt"

        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
// sharedInformers based on type
type GenericInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() cache.GenericLister
}

type genericInformer struct {
        informer cache.SharedIndexInformer
        resource schema.GroupResource
}

// Informer returns the SharedIndexInformer.
func (f *genericInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.informer
}</span>

// Lister returns the GenericLister.
func (f *genericInformer) Lister() cache.GenericLister <span class="cov0" title="0">{
        return cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)
}</span>

// ForResource gives generic access to a shared informer of the matching type
// TODO extend this to unknown resources with a client pool
func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) <span class="cov0" title="0">{
        switch resource </span>{
        // Group=kubeupgrade.heathcliff.eu, Version=v1alpha1
        case v1alpha1.SchemeGroupVersion.WithResource("kubeupgradeplans"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Kubeupgrade().V1alpha1().KubeUpgradePlans().Informer()}, nil</span>

        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no informer found for %v", resource)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by informer-gen. DO NOT EDIT.

package kubeupgrade

import (
        internalinterfaces "github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/internalinterfaces"
        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/kubeupgrade/v1alpha1"
)

// Interface provides access to each of this group's versions.
type Interface interface {
        // V1alpha1 provides access to shared informers for resources in V1alpha1.
        V1alpha1() v1alpha1.Interface
}

type group struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// V1alpha1 returns a new v1alpha1.Interface.
func (g *group) V1alpha1() v1alpha1.Interface <span class="cov0" title="0">{
        return v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        internalinterfaces "github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // KubeUpgradePlans returns a KubeUpgradePlanInformer.
        KubeUpgradePlans() KubeUpgradePlanInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// KubeUpgradePlans returns a KubeUpgradePlanInformer.
func (v *version) KubeUpgradePlans() KubeUpgradePlanInformer <span class="cov0" title="0">{
        return &amp;kubeUpgradePlanInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        "context"
        time "time"

        kubeupgradev1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        versioned "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned"
        internalinterfaces "github.com/heathcliff26/kube-upgrade/pkg/client/informers/externalversions/internalinterfaces"
        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/client/listers/kubeupgrade/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// KubeUpgradePlanInformer provides access to a shared informer and lister for
// KubeUpgradePlans.
type KubeUpgradePlanInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() v1alpha1.KubeUpgradePlanLister
}

type kubeUpgradePlanInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewKubeUpgradePlanInformer constructs a new informer for KubeUpgradePlan type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewKubeUpgradePlanInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredKubeUpgradePlanInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredKubeUpgradePlanInformer constructs a new informer for KubeUpgradePlan type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredKubeUpgradePlanInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.KubeupgradeV1alpha1().KubeUpgradePlans(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.KubeupgradeV1alpha1().KubeUpgradePlans(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;kubeupgradev1alpha1.KubeUpgradePlan{},
                resyncPeriod,
                indexers,
        )
}

func (f *kubeUpgradePlanInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredKubeUpgradePlanInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *kubeUpgradePlanInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;kubeupgradev1alpha1.KubeUpgradePlan{}, f.defaultInformer)
}</span>

func (f *kubeUpgradePlanInformer) Lister() v1alpha1.KubeUpgradePlanLister <span class="cov0" title="0">{
        return v1alpha1.NewKubeUpgradePlanLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        v1alpha1 "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/listers"
        "k8s.io/client-go/tools/cache"
)

// KubeUpgradePlanLister helps list KubeUpgradePlans.
// All objects returned here must be treated as read-only.
type KubeUpgradePlanLister interface {
        // List lists all KubeUpgradePlans in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*v1alpha1.KubeUpgradePlan, err error)
        // KubeUpgradePlans returns an object that can list and get KubeUpgradePlans.
        KubeUpgradePlans(namespace string) KubeUpgradePlanNamespaceLister
        KubeUpgradePlanListerExpansion
}

// kubeUpgradePlanLister implements the KubeUpgradePlanLister interface.
type kubeUpgradePlanLister struct {
        listers.ResourceIndexer[*v1alpha1.KubeUpgradePlan]
}

// NewKubeUpgradePlanLister returns a new KubeUpgradePlanLister.
func NewKubeUpgradePlanLister(indexer cache.Indexer) KubeUpgradePlanLister <span class="cov0" title="0">{
        return &amp;kubeUpgradePlanLister{listers.New[*v1alpha1.KubeUpgradePlan](indexer, v1alpha1.Resource("kubeupgradeplan"))}
}</span>

// KubeUpgradePlans returns an object that can list and get KubeUpgradePlans.
func (s *kubeUpgradePlanLister) KubeUpgradePlans(namespace string) KubeUpgradePlanNamespaceLister <span class="cov0" title="0">{
        return kubeUpgradePlanNamespaceLister{listers.NewNamespaced[*v1alpha1.KubeUpgradePlan](s.ResourceIndexer, namespace)}
}</span>

// KubeUpgradePlanNamespaceLister helps list and get KubeUpgradePlans.
// All objects returned here must be treated as read-only.
type KubeUpgradePlanNamespaceLister interface {
        // List lists all KubeUpgradePlans in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*v1alpha1.KubeUpgradePlan, err error)
        // Get retrieves the KubeUpgradePlan from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*v1alpha1.KubeUpgradePlan, error)
        KubeUpgradePlanNamespaceListerExpansion
}

// kubeUpgradePlanNamespaceLister implements the KubeUpgradePlanNamespaceLister
// interface.
type kubeUpgradePlanNamespaceLister struct {
        listers.ResourceIndexer[*v1alpha1.KubeUpgradePlan]
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package controller

import (
        "context"
        "fmt"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
        "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/scheme"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/kubernetes"
        clientv1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/klog/v2"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        "sigs.k8s.io/controller-runtime/pkg/manager/signals"
)

func init() <span class="cov8" title="1">{
        ctrl.SetLogger(klog.NewKlogr())
}</span>

type controller struct {
        client.Client
        manager manager.Manager
        nodes   clientv1.NodeInterface
}

// Run make generate when changing these comments
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans/status,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=nodes,verbs=list;update

func NewController(name string) (*controller, error) <span class="cov0" title="0">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ns, err := GetNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(config, manager.Options{
                Scheme:                        scheme.Scheme,
                LeaderElection:                true,
                LeaderElectionNamespace:       ns,
                LeaderElectionID:              name,
                LeaderElectionReleaseOnCancel: true,
                LeaseDuration:                 Pointer(time.Minute),
                RenewDeadline:                 Pointer(10 * time.Second),
                RetryPeriod:                   Pointer(5 * time.Second),
                HealthProbeBindAddress:        ":9090",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddHealthzCheck("healthz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddReadyzCheck("readyz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;controller{
                manager: mgr,
                nodes:   client.CoreV1().Nodes(),
                Client:  mgr.GetClient(),
        }, nil</span>
}

func (c *controller) Run() error <span class="cov0" title="0">{
        err := ctrl.NewControllerManagedBy(c.manager).For(&amp;v1alpha1.KubeUpgradePlan{}).Complete(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return c.manager.Start(signals.SetupSignalHandler())</span>
}

func (c *controller) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := klog.LoggerWithValues(klog.NewKlogr(), "plan", req.Name)

        var plan v1alpha1.KubeUpgradePlan
        err := c.Get(ctx, req.NamespacedName, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to get Plan")
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if plan.Status.Groups == nil </span><span class="cov0" title="0">{
                plan.Status.Groups = make(map[string]string, len(plan.Spec.Groups))
        }</span>

        <span class="cov0" title="0">for name, cfg := range plan.Spec.Groups </span><span class="cov0" title="0">{
                if groupWaitForDependency(cfg.DependsOn, plan.Status.Groups) </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Info("Group is waiting on dependencies")
                        plan.Status.Groups[name] = v1alpha1.PlanStatusWaiting
                        continue</span>
                }

                <span class="cov0" title="0">nodes, err := c.nodes.List(ctx, metav1.ListOptions{
                        LabelSelector: labels.SelectorFromSet(cfg.Labels).String(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to get nodes for group")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov0" title="0">status, err := c.reconcileNodes(ctx, plan.Spec.KubernetesVersion, nodes.Items)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to reconcile nodes for group")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov0" title="0">if plan.Status.Groups[name] != status </span><span class="cov0" title="0">{
                        logger.WithValues("group", name, "status", status).Info("Group changed status")
                        plan.Status.Groups[name] = status
                }</span>
        }

        <span class="cov0" title="0">plan.Status.Summary = createStatusSummary(plan.Status.Groups)

        err = c.Status().Update(ctx, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to update plan")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{
                Requeue:      plan.Status.Summary != v1alpha1.PlanStatusComplete,
                RequeueAfter: time.Minute,
        }, nil</span>
}

func (c *controller) reconcileNodes(ctx context.Context, kubeVersion string, nodes []corev1.Node) (string, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return v1alpha1.PlanStatusUnknown, nil
        }</span>

        <span class="cov0" title="0">completed := true

        for _, node := range nodes </span><span class="cov0" title="0">{
                if node.Annotations == nil </span><span class="cov0" title="0">{
                        node.Annotations = make(map[string]string)
                }</span>

                <span class="cov0" title="0">if node.Annotations[constants.KubernetesVersionAnnotation] == kubeVersion </span><span class="cov0" title="0">{
                        if node.Annotations[constants.KubernetesUpgradeStatus] != constants.NodeUpgradeStatusCompleted </span><span class="cov0" title="0">{
                                completed = false
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">completed = false
                node.Annotations[constants.KubernetesVersionAnnotation] = kubeVersion
                node.Annotations[constants.KubernetesUpgradeStatus] = constants.NodeUpgradeStatusPending

                _, err := c.nodes.Update(ctx, &amp;node, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to update node %s: %v", node.GetName(), err)
                }</span>
        }

        <span class="cov0" title="0">var status string
        if completed </span><span class="cov0" title="0">{
                status = v1alpha1.PlanStatusComplete
        }</span> else<span class="cov0" title="0"> {
                status = v1alpha1.PlanStatusProgressing
        }</span>
        <span class="cov0" title="0">return status, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package controller

import "fmt"

type ErrorGetNamespace struct {
        path string
        err  error
}

func NewErrorGetNamespace(path string, err error) error <span class="cov8" title="1">{
        return &amp;ErrorGetNamespace{
                path: path,
                err:  err,
        }
}</span>

func (e *ErrorGetNamespace) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Could not retrieve namespace from \"%s\": %v", e.path, e.err)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package controller

import (
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1"
)

var serviceAccountNamespaceFile = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"

const namespaceKubeUpgrade = "kube-upgrade"

// Read the namespace from the inserted serviceaccount file. Fallback to default if the file does not exist.
func GetNamespace() (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(serviceAccountNamespaceFile)
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return "", NewErrorGetNamespace(serviceAccountNamespaceFile, err)
                }</span> else<span class="cov8" title="1"> {
                        return namespaceKubeUpgrade, nil
                }</span>
        }

        <span class="cov8" title="1">ns := strings.TrimSpace(string(data))
        if len(ns) == 0 </span><span class="cov8" title="1">{
                return "", NewErrorGetNamespace(serviceAccountNamespaceFile, fmt.Errorf("file was empty"))
        }</span>
        <span class="cov8" title="1">return ns, nil</span>
}

// Return a pointer to the variable value
func Pointer[T any](v T) *T <span class="cov8" title="1">{
        return &amp;v
}</span>

// Check if the given group needs to wait on another one
func groupWaitForDependency(deps []string, status map[string]string) bool <span class="cov0" title="0">{
        for _, d := range deps </span><span class="cov0" title="0">{
                if status[d] != v1alpha1.PlanStatusComplete </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Return the status summary from the given input
func createStatusSummary(status map[string]string) string <span class="cov0" title="0">{
        if len(status) == 0 </span><span class="cov0" title="0">{
                return v1alpha1.PlanStatusUnknown
        }</span>
        <span class="cov0" title="0">waiting := false
        unknown := false
        progressing := false

        for _, v := range status </span><span class="cov0" title="0">{
                switch v </span>{
                case v1alpha1.PlanStatusComplete:<span class="cov0" title="0"></span>
                case v1alpha1.PlanStatusProgressing:<span class="cov0" title="0">
                        progressing = true</span>
                case v1alpha1.PlanStatusWaiting:<span class="cov0" title="0">
                        waiting = true</span>
                default:<span class="cov0" title="0">
                        unknown = true</span>
                }
        }

        <span class="cov0" title="0">if unknown </span><span class="cov0" title="0">{
                return v1alpha1.PlanStatusUnknown
        }</span> else<span class="cov0" title="0"> if progressing </span><span class="cov0" title="0">{
                return v1alpha1.PlanStatusProgressing
        }</span> else<span class="cov0" title="0"> if waiting </span><span class="cov0" title="0">{
                return v1alpha1.PlanStatusWaiting
        }</span> else<span class="cov0" title="0"> {
                return v1alpha1.PlanStatusComplete
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package upgradecontroller

import (
        "github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller"
        "github.com/heathcliff26/kube-upgrade/pkg/version"
        "k8s.io/klog/v2"

        "github.com/spf13/cobra"
)

const Name = "upgrade-controller"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgradeController()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to execute command: %v", err)
        }</span>
}

func NewUpgradeController() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " runs the controller to orchestrate cluster wide kubernetes upgrades.",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        run()
                        return nil
                }</span>,
        }

        <span class="cov8" title="1">rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run() <span class="cov0" title="0">{
        ctrl, err := controller.NewController(Name)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to create controller: %v", err)
        }</span>
        <span class="cov0" title="0">err = ctrl.Run()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Controller exited with error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package config

import (
        "log/slog"
        "os"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

const (
        DEFAULT_CONFIG_PATH = "/etc/kube-upgraded/config.yaml"

        DEFAULT_LOG_LEVEL       = "info"
        DEFAULT_KUBECONFIG      = "/etc/kubernetes/kubelet.conf"
        DEFAULT_IMAGE           = "ghcr.io/heathcliff26/fcos-k8s"
        DEFAULT_FLEETLOCK_GROUP = "default"
        DEFAULT_RPM_OSTREE_PATH = "/usr/bin/rpm-ostree"
        DEFAULT_KUBEADM_PATH    = "/usr/bin/kubeadm"
        DEFAULT_CHECK_INTERVAL  = 3 * time.Hour
        DEFAULT_RETRY_INTERVAL  = 5 * time.Minute
)

var logLevel = &amp;slog.LevelVar{}

// Initialize the logger
func init() <span class="cov8" title="1">{
        logLevel = &amp;slog.LevelVar{}
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>

type Config struct {
        // The log level used by slog, default "info"
        LogLevel string `yaml:"logLevel,omitempty"`
        // The path to the kubeconfig file, default is the kubelet config under "/etc/kubernetes/kubelet.conf"
        Kubeconfig string `yaml:"kubeconfig,omitempty"`
        // The container image repository for os rebases
        Image string `yaml:"image,omitempty"`
        // Configuration for fleetlock node locking
        Fleetlock FleetlockConfig `yaml:"fleetlock"`
        // The path to the rpm-ostree binary, default "/usr/bin/rpm-ostree"
        RPMOStreePath string `yaml:"rpm-ostree-path,omitempty"`
        // The path to the kubeadm binary, default "/usr/bin/kubeadm"
        KubeadmPath string `yaml:"kubeadm-path,omitempty"`

        // The interval between regular checks, default 3h
        CheckInterval time.Duration `yaml:"check-interval,omitempty"`
        // The interval between retries when an operation fails, default 5m
        RetryInterval time.Duration `yaml:"retry-interval,omitempty"`
}

type FleetlockConfig struct {
        // URL to fleetlock server
        URL string `yaml:"url"`
        // The node group to use for fleetlock, default group is "default"
        Group string `yaml:"group,omitempty"`
}

// Parse a given string and set the resulting log level
func setLogLevel(level string) error <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="1">
                logLevel.Set(slog.LevelDebug)</span>
        case "info":<span class="cov8" title="1">
                logLevel.Set(slog.LevelInfo)</span>
        case "warn":<span class="cov8" title="1">
                logLevel.Set(slog.LevelWarn)</span>
        case "error":<span class="cov8" title="1">
                logLevel.Set(slog.LevelError)</span>
        default:<span class="cov8" title="1">
                return NewErrUnknownLogLevel(level)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                LogLevel:   DEFAULT_LOG_LEVEL,
                Kubeconfig: DEFAULT_KUBECONFIG,
                Image:      DEFAULT_IMAGE,
                Fleetlock: FleetlockConfig{
                        Group: DEFAULT_FLEETLOCK_GROUP,
                },
                RPMOStreePath: DEFAULT_RPM_OSTREE_PATH,
                KubeadmPath:   DEFAULT_KUBEADM_PATH,
                CheckInterval: DEFAULT_CHECK_INTERVAL,
                RetryInterval: DEFAULT_RETRY_INTERVAL,
        }
}</span>

// Loads the config from the given path.
// When path is empty, it checks the default path "/etc/kube-upgraded/config.yaml".
// When no config is found in the default path, it returns the default config.
// Returns error when the given config is invalid.
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        c := DefaultConfig()

        p := path
        if path == "" </span><span class="cov8" title="1">{
                p = DEFAULT_CONFIG_PATH
        }</span>

        <span class="cov8" title="1">f, err := os.ReadFile(p)
        if os.IsNotExist(err) &amp;&amp; path == "" </span><span class="cov8" title="1">{
                return c, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(f, &amp;c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = setLogLevel(c.LogLevel)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package config

type ErrUnknownLogLevel struct {
        level string
}

func NewErrUnknownLogLevel(level string) error <span class="cov8" title="1">{
        return &amp;ErrUnknownLogLevel{
                level: level,
        }
}</span>

func (e *ErrUnknownLogLevel) Error() string <span class="cov0" title="0">{
        return "Unknown log level " + e.level
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/fleetlock"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm"
        rpmostree "github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree"
        "gopkg.in/yaml.v3"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/client-go/tools/clientcmd"
)

type daemon struct {
        fleetlock     *fleetlock.FleetlockClient
        checkInterval time.Duration
        retryInterval time.Duration

        rpmostree *rpmostree.RPMOStreeCMD
        kubeadm   *kubeadm.KubeadmCMD

        image string
        node  string

        client kubernetes.Interface
        ctx    context.Context
        cancel context.CancelFunc

        upgrade sync.Mutex
}

// Create a new daemon
func NewDaemon(cfg *config.Config) (*daemon, error) <span class="cov0" title="0">{
        fleetlockClient, err := fleetlock.NewClient(cfg.Fleetlock.URL, cfg.Fleetlock.Group)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create fleetlock client: %v", err)
        }</span>

        <span class="cov0" title="0">rpmOstreeCMD, err := rpmostree.New(cfg.RPMOStreePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create rpm-ostree cmd wrapper: %v", err)
        }</span>
        <span class="cov0" title="0">kubeadmCMD, err := kubeadm.New(cfg.KubeadmPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubeadm cmd wrapper: %v", err)
        }</span>

        <span class="cov0" title="0">if cfg.Kubeconfig == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no kubeconfig provided")
        }</span>
        <span class="cov0" title="0">config, err := clientcmd.BuildConfigFromFlags("", cfg.Kubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read kubeconfig: %v", err)
        }</span>
        <span class="cov0" title="0">kubeClient, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %v", err)
        }</span>

        <span class="cov0" title="0">if cfg.Image == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no image provided for kubernetes updates")
        }</span>

        <span class="cov0" title="0">node, err := findNodeByMachineID(kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get kubernetes node name for host: %v", err)
        }</span>
        <span class="cov0" title="0">slog.Info("Found node name for this host", slog.String("node", node))

        return &amp;daemon{
                fleetlock:     fleetlockClient,
                checkInterval: cfg.CheckInterval,
                retryInterval: cfg.RetryInterval,

                rpmostree: rpmOstreeCMD,
                kubeadm:   kubeadmCMD,

                image:  cfg.Image,
                node:   node,
                client: kubeClient,
        }, nil</span>
}

// Retries the given function until it succeeds
func (d *daemon) retry(f func() bool) <span class="cov0" title="0">{
        for !f() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(d.retryInterval):<span class="cov0" title="0"></span>
                }
        }
}

// Will try to release the lock until successfull
func (d *daemon) releaseLock() <span class="cov0" title="0">{
        d.retry(func() bool </span><span class="cov0" title="0">{
                err := d.fleetlock.Release()
                if err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">slog.Warn("Failed to release lock", "err", err)
                return false</span>
        })
}

// Run the main daemon loop
func (d *daemon) Run() error <span class="cov0" title="0">{
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
        ctx, cancel := context.WithCancel(context.Background())
        d.ctx = ctx
        d.cancel = cancel
        go func() </span><span class="cov0" title="0">{
                &lt;-stop
                cancel()
        }</span>()

        <span class="cov0" title="0">node, err := d.client.CoreV1().Nodes().Get(d.ctx, d.node, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get node status: %v", err)
        }</span>

        <span class="cov0" title="0">if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                slog.Debug("Releasing any log that may be held by this machine")
                d.releaseLock()
                if d.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                slog.Info("Node is in the middle of a kubernetes upgrade, not releasing the lock")
        }</span>

        <span class="cov0" title="0">slog.Info("Starting daemon")

        var wg sync.WaitGroup
        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForUpgrade()
                slog.Info("Stopped watching for upgrades")
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForKubernetesUpgrade()
                slog.Info("Stopped watching for kubernetes upgrades")
        }</span>()

        <span class="cov0" title="0">wg.Wait()
        return nil</span>
}

// Check for os upgrades and perform them if necessary.
// Runs until context is cancelled
func (d *daemon) watchForUpgrade() <span class="cov0" title="0">{
        var needUpgrade bool
        for </span><span class="cov0" title="0">{
                d.retry(func() bool </span><span class="cov0" title="0">{
                        var err error
                        slog.Debug("Checking for upgrades via rpm-ostree")
                        needUpgrade, err = d.rpmostree.CheckForUpgrade()
                        if err == nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">slog.Error("Failed to check if there is a new upgrade", "err", err)
                        return false</span>
                })

                <span class="cov0" title="0">if needUpgrade </span><span class="cov0" title="0">{
                        slog.Info("New upgrade is necessary, trying to start update")
                        d.retry(func() bool </span><span class="cov0" title="0">{
                                err := d.doUpgrade()
                                if err == nil </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                                <span class="cov0" title="0">slog.Error("Failed to perform rpm-ostree upgrade", "err", err)
                                return false</span>
                        })
                } else<span class="cov0" title="0"> {
                        slog.Debug("No upgrades found")
                }</span>

                <span class="cov0" title="0">select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(d.checkInterval):<span class="cov0" title="0"></span>
                }
        }
}

// Perform rpm-ostree upgrade
func (d *daemon) doUpgrade() error <span class="cov0" title="0">{
        d.upgrade.Lock()
        defer d.upgrade.Unlock()

        err := d.fleetlock.Lock()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to aquire lock: %v", err)
        }</span>

        <span class="cov0" title="0">err = d.rpmostree.Upgrade()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // This should not be reached, as rpmostree.Upgrade() reboots the node on success.
        // I included it here mainly for completness sake.

        <span class="cov0" title="0">d.releaseLock()
        return nil</span>
}

// Watch for kubernetes upgrades and preform them if necessary
func (d *daemon) watchForKubernetesUpgrade() <span class="cov0" title="0">{
        factory := informers.NewSharedInformerFactoryWithOptions(d.client, time.Minute, informers.WithTweakListOptions(func(opts *metav1.ListOptions) </span><span class="cov0" title="0">{
                opts.FieldSelector = fields.SelectorFromSet(fields.Set{"metadata.name": d.node}).String()
        }</span>))

        <span class="cov0" title="0">informer := factory.Core().V1().Nodes().Informer()
        _, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: d.checkNodeStatus,
                UpdateFunc: func(_, newObj interface{}) </span><span class="cov0" title="0">{
                        d.checkNodeStatus(newObj)
                }</span>,
                DeleteFunc: func(_ interface{}) <span class="cov0" title="0">{
                        slog.Error("Node has been deleted from cluster")
                        d.cancel()
                }</span>,
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to add event handlers to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">err = informer.SetWatchErrorHandler(cache.DefaultWatchErrorHandler)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to set watch error handler to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">slog.Info("Watching for new kubernetes upgrades")
        informer.Run(d.ctx.Done())</span>
}

// Check if we need to upgrade the node and trigger the upgrade if needed
func (d *daemon) checkNodeStatus(obj interface{}) <span class="cov0" title="0">{
        node := obj.(*corev1.Node)

        if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d.retry(func() bool </span><span class="cov0" title="0">{
                err := d.doNodeUpgrade(node)
                if err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">slog.Error("Failed to upgrade node", "err", err, slog.String("node", node.GetName()))
                return false</span>
        })
}

// Update the node by first rebasing to a new version and then upgrading kubernetes
func (d *daemon) doNodeUpgrade(node *corev1.Node) error <span class="cov0" title="0">{
        d.upgrade.Lock()
        defer d.upgrade.Unlock()

        version := node.Annotations[constants.KubernetesVersionAnnotation]
        slog.Info("Attempting node upgrade to new kubernetes version", slog.String("node", node.GetName()), slog.String("version", version))

        err := d.fleetlock.Lock()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to aquire lock: %v", err)
        }</span>

        <span class="cov0" title="0">if version != node.Status.NodeInfo.KubeletVersion </span><span class="cov0" title="0">{
                slog.Info("Rebasing os to new kubernetes version", slog.String("version", version))
                err := d.updateNodeStatus(constants.NodeUpgradeStatusRebasing)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update node status: %v", err)
                }</span>
                <span class="cov0" title="0">err = d.rpmostree.Rebase(d.image + ":" + version)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rebase node: %v", err)
                }</span>
        }

        <span class="cov0" title="0">slog.Info("Updating node via kubeadm")

        err = d.updateNodeStatus(constants.NodeUpgradeStatusUpgrading)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        <span class="cov0" title="0">kubeadmConfigMap, err := d.client.CoreV1().ConfigMaps("kube-system").Get(d.ctx, "kubeadm-config", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch kubeadm-config: %v", err)
        }</span>
        <span class="cov0" title="0">if kubeadmConfigMap.Data == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubeadm configmap contains no data")
        }</span>
        <span class="cov0" title="0">var kubeadmConfig kubeadm.ClusterConfiguration
        err = yaml.Unmarshal([]byte(kubeadmConfigMap.Data["ClusterConfiguration"]), &amp;kubeadmConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse kubeadm-config: %v", err)
        }</span>

        <span class="cov0" title="0">if version != kubeadmConfig.KubernetesVersion </span><span class="cov0" title="0">{
                slog.Info("kubeadm-config kubernetesVersion does not match requested version, initializing upgrade", slog.String("kubernetesVersion", kubeadmConfig.KubernetesVersion), slog.String("version", version))
                err = d.kubeadm.Apply(version)
        }</span> else<span class="cov0" title="0"> {
                slog.Debug("Cluster upgrade is already initialized, upgrading node")
                err = d.kubeadm.Node()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed run kubeadm: %v", err)
        }</span>

        <span class="cov0" title="0">err = d.updateNodeStatus(constants.NodeUpgradeStatusCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        <span class="cov0" title="0">slog.Info("Finished node upgrade, releasing lock")
        d.releaseLock()
        return nil</span>
}

// Update the kube-upgrade node status annotation with the given status
func (d *daemon) updateNodeStatus(status string) error <span class="cov0" title="0">{
        node, err := d.client.CoreV1().Nodes().Get(d.ctx, d.node, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if node.Annotations == nil </span><span class="cov0" title="0">{
                node.Annotations = make(map[string]string)
        }</span>
        <span class="cov0" title="0">node.Annotations[constants.KubernetesUpgradeStatus] = status

        _, err = d.client.CoreV1().Nodes().Update(d.ctx, node, metav1.UpdateOptions{})
        if err == nil </span><span class="cov0" title="0">{
                slog.Debug("Set node status", slog.String("status", status))
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

// Find the node by the current machineID of this machine
func findNodeByMachineID(client kubernetes.Interface) (string, error) <span class="cov0" title="0">{
        machineID, err := utils.GetMachineID()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">nodes, err := client.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for _, node := range nodes.Items </span><span class="cov0" title="0">{
                if node.Status.NodeInfo.MachineID == machineID </span><span class="cov0" title="0">{
                        return node.GetName(), nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("found no node with matching machineID: %s", machineID)</span>
}

// Check if the node needs to upgrade it's kubernetes version
func nodeNeedsUpgrade(node *corev1.Node) bool <span class="cov0" title="0">{
        if node.Annotations == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">status := node.Annotations[constants.KubernetesUpgradeStatus]
        if status == constants.NodeUpgradeStatusCompleted </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if _, ok := node.Annotations[constants.KubernetesVersionAnnotation]; !ok </span><span class="cov0" title="0">{
                slog.Warn("Missing version annotation on node", slog.String("node", node.GetName()), slog.String("annotation", constants.KubernetesVersionAnnotation))
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package fleetlock

import (
        "fmt"
        "net/http"

        "github.com/heathcliff26/fleetlock/pkg/server/client"
)

type FleetlockClient struct {
        url   string
        group string
        appID string
}

// Create a new client for fleetlock
func NewClient(url, group string) (*FleetlockClient, error) <span class="cov0" title="0">{
        if url == "" || group == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("at least one of the required parameters is empty")
        }</span>

        <span class="cov0" title="0">appID, err := GetZincateAppID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create zincati app id: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;FleetlockClient{
                url:   url,
                group: group,
                appID: appID,
        }, nil</span>
}

// Aquire a lock for this machine
func (c *FleetlockClient) Lock() error <span class="cov0" title="0">{
        ok, res, err := c.doRequest("/v1/pre-reboot")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("failed to aquire lock kind=\"%s\" reason=\"%s\"", res.Kind, res.Value)</span>
}

// Release the hold lock
func (c *FleetlockClient) Release() error <span class="cov0" title="0">{
        ok, res, err := c.doRequest("/v1/steady-state")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("failed to release lock kind=\"%s\" reason=\"%s\"", res.Kind, res.Value)</span>
}

func (c *FleetlockClient) doRequest(path string) (bool, client.FleetLockResponse, error) <span class="cov0" title="0">{
        body, err := client.PrepareRequest(c.group, c.appID)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("Failed to prepare request body: %v", err)
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequest(http.MethodPost, c.url+path, body)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("Failed to create http post request: %v", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("fleet-lock-protocol", "true")
        req.Header.Set("Content-Type", "application/json")

        res, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("Failed to send request to server: %v", err)
        }</span>

        <span class="cov0" title="0">resBody, err := client.ParseResponse(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("Failed to prepare request body: %v", err)
        }</span>

        <span class="cov0" title="0">return res.StatusCode == http.StatusOK, resBody, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package fleetlock

import (
        systemdutils "github.com/heathcliff26/fleetlock/pkg/systemd-utils"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

// Find the machine-id of the current node and generate a zincati appID from it.
func GetZincateAppID() (string, error) <span class="cov0" title="0">{
        machineID, err := utils.GetMachineID()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">appID, err := systemdutils.ZincatiMachineID(machineID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return appID, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package kubeadm

import (
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type KubeadmCMD struct {
        binary string
        mutex  sync.Mutex
}

// Create a new wrapper for kubeadm
func New(path string) (*KubeadmCMD, error) <span class="cov0" title="0">{
        err := utils.CheckExistsAndIsExecutable(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;KubeadmCMD{
                binary: path,
        }, nil</span>
}

// Run kubeadm upgrade apply
func (k *KubeadmCMD) Apply(version string) error <span class="cov0" title="0">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateCMDWithStdout(k.binary, "upgrade", "apply", "--yes", version).Run()
}</span>

// Run kubeadm upgrade node
func (k *KubeadmCMD) Node() error <span class="cov0" title="0">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateCMDWithStdout(k.binary, "upgrade", "node").Run()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package upgraded

import (
        "log/slog"
        "os"
        "os/user"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon"
        "github.com/heathcliff26/kube-upgrade/pkg/version"

        "github.com/spf13/cobra"
)

const Name = "upgraded"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgraded()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Command exited with error", "err", err)
                os.Exit(1)
        }</span>
}

func NewUpgraded() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " daemon for keeping the system up-to-date",
                Run: func(cmd *cobra.Command, _ []string) </span><span class="cov0" title="0">{
                        cfg, err := cmd.Flags().GetString("config")
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to parse config file flag", "err", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">run(cfg)</span>
                },
        }

        <span class="cov8" title="1">rootCmd.Flags().StringP("config", "c", "", "Path to config file")
        rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run(cfgPath string) <span class="cov0" title="0">{
        cfg, err := config.LoadConfig(cfgPath)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load config file", "err", err, slog.String("path", cfgPath))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">u, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to check if running as root", "err", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if u.Username != "root" </span><span class="cov0" title="0">{
                slog.Error("Need to be root")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">d, err := daemon.NewDaemon(cfg)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create a new daemon", "err", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = d.Run()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Daemon exited with error", "err", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package rpmostree

import (
        "fmt"
        "os/exec"
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type RPMOStreeCMD struct {
        binary string
        mutex  sync.Mutex
}

// Create a new wrapper for rpm-ostree
func New(path string) (*RPMOStreeCMD, error) <span class="cov0" title="0">{
        err := utils.CheckExistsAndIsExecutable(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;RPMOStreeCMD{
                binary: path,
        }, nil</span>
}

// Run rpm-ostree and check for new updates
func (r *RPMOStreeCMD) CheckForUpgrade() (bool, error) <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        cmd := exec.Command(r.binary, "upgrade", "--check")
        out, err := cmd.CombinedOutput()
        code, ok := getExitCode(err)
        if !ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                fmt.Println(string(out))
                return false, err
        }</span> else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                code = 0
        }</span>

        <span class="cov0" title="0">switch code </span>{
        case 0:<span class="cov0" title="0">
                return true, nil</span>
        case 77:<span class="cov0" title="0">
                return false, nil</span>
        default:<span class="cov0" title="0">
                fmt.Println(string(out))
                return false, fmt.Errorf("rpm-ostree exited with unknown exit code %d", code)</span>
        }
}

// Upgrade the system using rpm-ostree. Writes command output to stdout/stderr.
//
// WARNING: Will reboot the system when successfull.
func (r *RPMOStreeCMD) Upgrade() error <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "upgrade", "--reboot").Run()
}</span>

// Rebases the system to the given container image
//
// WARNING: Will reboot the system when successfull.
func (r *RPMOStreeCMD) Rebase(image string) error <span class="cov0" title="0">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "rebase", "--reboot", "ostree-unverified-registry:"+image).Run()
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package rpmostree

import (
        "os/exec"
)

// Try to extract the exit code from the error.
func getExitCode(err error) (int, bool) <span class="cov0" title="0">{
        if exiterr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                return exiterr.ExitCode(), true
        }</span>
        <span class="cov0" title="0">return 0, false</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
)

// Read the machine-id from /etc/machine-id
func GetMachineID() (string, error) <span class="cov0" title="0">{
        b, err := os.ReadFile("/etc/machine-id")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">machineID := strings.TrimRight(string(b), "\r\n")
        return machineID, nil</span>
}

// Create a command that writes to stdout/stderr
func CreateCMDWithStdout(name string, arg ...string) *exec.Cmd <span class="cov0" title="0">{
        cmd := exec.Command(name, arg...)
        cmd.Stderr = os.Stderr
        cmd.Stdout = os.Stdout
        return cmd
}</span>

// Check if the given file exists and is executable
func CheckExistsAndIsExecutable(path string) error <span class="cov0" title="0">{
        f, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if f.Mode().Perm()&amp;0100 == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not an executable", path)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package version

import (
        "fmt"
        "runtime"
        "runtime/debug"

        "github.com/spf13/cobra"
)

var version = "devel"

func NewCommand(name string) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information and exit",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Print(Version(name))
                }</span>,
        }
        // Override to prevent parent function from running
        <span class="cov8" title="1">cmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span>{<span class="cov0" title="0">}</span>

        <span class="cov8" title="1">return cmd</span>
}

func Version(name string) string <span class="cov8" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov0" title="0">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span> else<span class="cov8" title="1"> if commit == "" </span><span class="cov8" title="1">{
                commit = "Unknown"
        }</span>

        <span class="cov8" title="1">result := name + ":\n"
        result += "    Version: " + version + "\n"
        result += "    Commit:  " + commit + "\n"
        result += "    Go:      " + runtime.Version() + "\n"

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
