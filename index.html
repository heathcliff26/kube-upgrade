
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>upgrade-controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/kube-upgrade/cmd/upgrade-controller/main.go (0.0%)</option>
				
				<option value="file1">github.com/heathcliff26/kube-upgrade/cmd/upgraded/main.go (0.0%)</option>
				
				<option value="file2">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/defaults.go (0.0%)</option>
				
				<option value="file3">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/register.go (83.3%)</option>
				
				<option value="file4">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/validation.go (0.0%)</option>
				
				<option value="file5">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/defaults.go (100.0%)</option>
				
				<option value="file6">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/register.go (83.3%)</option>
				
				<option value="file7">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/validation.go (100.0%)</option>
				
				<option value="file8">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/config.go (100.0%)</option>
				
				<option value="file9">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/controller.go (54.0%)</option>
				
				<option value="file10">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/errors.go (50.0%)</option>
				
				<option value="file11">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/mutatingwebhook.go (100.0%)</option>
				
				<option value="file12">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/utils.go (96.8%)</option>
				
				<option value="file13">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/validatingwebhook.go (100.0%)</option>
				
				<option value="file14">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/root.go (23.5%)</option>
				
				<option value="file15">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/config.go (100.0%)</option>
				
				<option value="file16">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/errors.go (50.0%)</option>
				
				<option value="file17">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/config.go (94.9%)</option>
				
				<option value="file18">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/daemon.go (44.9%)</option>
				
				<option value="file19">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/nodes.go (33.7%)</option>
				
				<option value="file20">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/stream.go (35.3%)</option>
				
				<option value="file21">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/utils.go (93.8%)</option>
				
				<option value="file22">github.com/heathcliff26/kube-upgrade/pkg/upgraded/fleetlock/client.go (87.7%)</option>
				
				<option value="file23">github.com/heathcliff26/kube-upgrade/pkg/upgraded/fleetlock/utils.go (81.8%)</option>
				
				<option value="file24">github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm/kubeadm.go (70.0%)</option>
				
				<option value="file25">github.com/heathcliff26/kube-upgrade/pkg/upgraded/root.go (14.3%)</option>
				
				<option value="file26">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/rpm-ostree.go (92.0%)</option>
				
				<option value="file27">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/utils.go (100.0%)</option>
				
				<option value="file28">github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils/utils.go (93.3%)</option>
				
				<option value="file29">github.com/heathcliff26/kube-upgrade/pkg/version/version.go (73.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import controller "github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller"

func main() <span class="cov0" title="0">{
        controller.Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import upgraded "github.com/heathcliff26/kube-upgrade/pkg/upgraded"

func main() <span class="cov0" title="0">{
        upgraded.Execute()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package v1alpha1

const (
        DefaultStatus = "Unknown"
)

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov0" title="0">{
        if spec.Groups == nil </span><span class="cov0" title="0">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                if group.Labels == nil </span><span class="cov0" title="0">{
                        group.Labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">spec.Groups[name] = group</span>
        }
        <span class="cov0" title="0">if spec.Upgraded != nil </span><span class="cov0" title="0">{
                SetObjectDefaults_UpgradedConfig(spec.Upgraded)
        }</span>
}

func SetObjectDefaults_UpgradedConfig(cfg *UpgradedConfig) <span class="cov0" title="0">{
        if cfg.Stream == "" </span><span class="cov0" title="0">{
                cfg.Stream = "ghcr.io/heathcliff26/fcos-k8s"
        }</span>
        <span class="cov0" title="0">if cfg.FleetlockGroup == "" </span><span class="cov0" title="0">{
                cfg.FleetlockGroup = "default"
        }</span>
        <span class="cov0" title="0">if cfg.CheckInterval == "" </span><span class="cov0" title="0">{
                cfg.CheckInterval = "3h"
        }</span>
        <span class="cov0" title="0">if cfg.RetryInterval == "" </span><span class="cov0" title="0">{
                cfg.RetryInterval = "5m"
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha1",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov8" title="1">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(addKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package v1alpha1

import (
        "fmt"
        "net/url"
        "regexp"
        "slices"
        "time"
)

var (
        validStatusValues = []string{"Unknown", "Waiting", "Progressing", "Complete"}
)

func ValidateObject_KubeUpgradePlan(plan *KubeUpgradePlan) error <span class="cov0" title="0">{
        err := ValidateObject_KubeUpgradeSpec(plan.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ValidateObject_KubeUpgradeStatus(plan.Status)</span>
}

func ValidateObject_KubeUpgradeSpec(spec KubeUpgradeSpec) error <span class="cov0" title="0">{
        versionRegex := regexp.MustCompile(`^v[0-9]+\.[0-9]+\.[0-9]+$`)
        if !versionRegex.MatchString(spec.KubernetesVersion) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" is not a valid version", spec.KubernetesVersion)
        }</span>

        <span class="cov0" title="0">if len(spec.Groups) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("need at least one node group for upgrades")
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                for _, dependency := range group.DependsOn </span><span class="cov0" title="0">{
                        if _, ok := spec.Groups[dependency]; !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("group \"%s\" depends on non-existing group \"%s\"", name, dependency)
                        }</span>
                }
                <span class="cov0" title="0">if len(group.Labels) &lt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group \"%s\" needs at least one label", name)
                }</span>
                <span class="cov0" title="0">err := ValidateObject_UpgradedConfig(group.Upgraded)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("group \"%s\" has an invalid upgraded config: %v", name, err)
                }</span>
        }

        <span class="cov0" title="0">err := ValidateObject_UpgradedConfig(spec.Upgraded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if spec.Upgraded != nil &amp;&amp; spec.Upgraded.FleetlockURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter spec.upgraded.fleetlock-url")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateObject_UpgradedConfig(cfg *UpgradedConfig) error <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cfg.Stream != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI("http://" + cfg.Stream)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for stream: %v", cfg.Stream, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.FleetlockURL != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI(cfg.FleetlockURL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for fleetlock-url: %v", cfg.FleetlockURL, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.CheckInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.CheckInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for check-interval: %v", cfg.CheckInterval, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.RetryInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.RetryInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for retry-interval: %v", cfg.RetryInterval, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ValidateObject_KubeUpgradeStatus(status KubeUpgradeStatus) error <span class="cov0" title="0">{
        // Mutating/Validation webhooks for subresources are called later, so it is ok if the status does not exist
        if status.Summary == "" &amp;&amp; len(status.Groups) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !slices.Contains(validStatusValues, status.Summary) </span><span class="cov0" title="0">{
                return fmt.Errorf("found unknown status \"%s\" in summary, accepted values are: %v", status.Summary, validStatusValues)
        }</span>

        <span class="cov0" title="0">for group, value := range status.Groups </span><span class="cov0" title="0">{
                if !slices.Contains(validStatusValues, value) </span><span class="cov0" title="0">{
                        return fmt.Errorf("found unknown status \"%s\" in group \"%s\", accepted values are: %v", value, group, validStatusValues)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package v1alpha2

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

const (
        DefaultStatus                 = "Unknown"
        DefaultUpgradedStream         = "ghcr.io/heathcliff26/fcos-k8s"
        DefaultUpgradedFleetlockGroup = "default"
        DefaultUpgradedCheckInterval  = "3h"
        DefaultUpgradedRetryInterval  = "5m"
)

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov8" title="1">{
        if spec.Groups == nil </span><span class="cov8" title="1">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov8" title="1">for name, group := range spec.Groups </span><span class="cov8" title="1">{
                if group.Labels == nil </span><span class="cov8" title="1">{
                        group.Labels = &amp;metav1.LabelSelector{}
                }</span>
                <span class="cov8" title="1">spec.Groups[name] = group</span>
        }
        <span class="cov8" title="1">SetObjectDefaults_UpgradedConfig(&amp;spec.Upgraded)</span>
}

func SetObjectDefaults_UpgradedConfig(cfg *UpgradedConfig) <span class="cov8" title="1">{
        if cfg.Stream == "" </span><span class="cov8" title="1">{
                cfg.Stream = "ghcr.io/heathcliff26/fcos-k8s"
        }</span>
        <span class="cov8" title="1">if cfg.FleetlockGroup == "" </span><span class="cov8" title="1">{
                cfg.FleetlockGroup = "default"
        }</span>
        <span class="cov8" title="1">if cfg.CheckInterval == "" </span><span class="cov8" title="1">{
                cfg.CheckInterval = "3h"
        }</span>
        <span class="cov8" title="1">if cfg.RetryInterval == "" </span><span class="cov8" title="1">{
                cfg.RetryInterval = "5m"
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package v1alpha2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha2",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov8" title="1">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(addKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package v1alpha2

import (
        "fmt"
        "net/url"
        "regexp"
        "slices"
        "time"
)

var (
        validStatusValues = []string{"Unknown", "Waiting", "Progressing", "Complete"}
)

func ValidateObject_KubeUpgradePlan(plan *KubeUpgradePlan) error <span class="cov8" title="1">{
        err := ValidateObject_KubeUpgradeSpec(plan.Spec)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return ValidateObject_KubeUpgradeStatus(plan.Status)</span>
}

func ValidateObject_KubeUpgradeSpec(spec KubeUpgradeSpec) error <span class="cov8" title="1">{
        versionRegex := regexp.MustCompile(`^v[0-9]+\.[0-9]+\.[0-9]+$`)
        if !versionRegex.MatchString(spec.KubernetesVersion) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" is not a valid version", spec.KubernetesVersion)
        }</span>

        <span class="cov8" title="1">if len(spec.Groups) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("need at least one node group for upgrades")
        }</span>
        <span class="cov8" title="1">for name, group := range spec.Groups </span><span class="cov8" title="1">{
                for _, dependency := range group.DependsOn </span><span class="cov8" title="1">{
                        if _, ok := spec.Groups[dependency]; !ok </span><span class="cov8" title="1">{
                                return fmt.Errorf("group \"%s\" depends on non-existing group \"%s\"", name, dependency)
                        }</span>
                }

                <span class="cov8" title="1">if group.Labels == nil || (len(group.Labels.MatchExpressions) &lt; 1 &amp;&amp; len(group.Labels.MatchLabels) &lt; 1) </span><span class="cov8" title="1">{
                        return fmt.Errorf("group \"%s\" needs at least one label selector", name)
                }</span>

                <span class="cov8" title="1">if group.Upgraded != nil </span><span class="cov8" title="1">{
                        err := ValidateObject_UpgradedConfig(*group.Upgraded)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("group \"%s\" has an invalid upgraded config: %v", name, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">err := ValidateObject_UpgradedConfig(spec.Upgraded)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if spec.Upgraded.FleetlockURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("missing parameter spec.upgraded.fleetlock-url")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ValidateObject_UpgradedConfig(cfg UpgradedConfig) error <span class="cov8" title="1">{
        if cfg.Stream != "" </span><span class="cov8" title="1">{
                _, err := url.ParseRequestURI("http://" + cfg.Stream)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for stream: %v", cfg.Stream, err)
                }</span>
        }

        <span class="cov8" title="1">if cfg.FleetlockURL != "" </span><span class="cov8" title="1">{
                _, err := url.ParseRequestURI(cfg.FleetlockURL)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for fleetlock-url: %v", cfg.FleetlockURL, err)
                }</span>
        }

        <span class="cov8" title="1">if cfg.CheckInterval != "" </span><span class="cov8" title="1">{
                _, err := time.ParseDuration(cfg.CheckInterval)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for check-interval: %v", cfg.CheckInterval, err)
                }</span>
        }

        <span class="cov8" title="1">if cfg.RetryInterval != "" </span><span class="cov8" title="1">{
                _, err := time.ParseDuration(cfg.RetryInterval)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for retry-interval: %v", cfg.RetryInterval, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ValidateObject_KubeUpgradeStatus(status KubeUpgradeStatus) error <span class="cov8" title="1">{
        // Mutating/Validation webhooks for subresources are called later, so it is ok if the status does not exist
        if status.Summary == "" &amp;&amp; len(status.Groups) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if !slices.Contains(validStatusValues, status.Summary) </span><span class="cov8" title="1">{
                return fmt.Errorf("found unknown status \"%s\" in summary, accepted values are: %v", status.Summary, validStatusValues)
        }</span>

        <span class="cov8" title="1">for group, value := range status.Groups </span><span class="cov8" title="1">{
                if !slices.Contains(validStatusValues, value) </span><span class="cov8" title="1">{
                        return fmt.Errorf("found unknown status \"%s\" in group \"%s\", accepted values are: %v", value, group, validStatusValues)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controller

import (
        "maps"
        "reflect"
        "strings"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
)

// Combine 2 configs, where group overrides the values used by global.
// Return the result as ready to use annotations.
func combineConfig(global api.UpgradedConfig, group *api.UpgradedConfig) map[string]string <span class="cov8" title="1">{
        if group == nil </span><span class="cov8" title="1">{
                return createConfigAnnotations(global)
        }</span>
        <span class="cov8" title="1">cfg := global

        if group.Stream != "" </span><span class="cov8" title="1">{
                cfg.Stream = group.Stream
        }</span>
        <span class="cov8" title="1">if group.FleetlockURL != "" </span><span class="cov8" title="1">{
                cfg.FleetlockURL = group.FleetlockURL
        }</span>
        <span class="cov8" title="1">if group.FleetlockGroup != "" </span><span class="cov8" title="1">{
                cfg.FleetlockGroup = group.FleetlockGroup
        }</span>
        <span class="cov8" title="1">if group.CheckInterval != "" </span><span class="cov8" title="1">{
                cfg.CheckInterval = group.CheckInterval
        }</span>
        <span class="cov8" title="1">if group.RetryInterval != "" </span><span class="cov8" title="1">{
                cfg.RetryInterval = group.RetryInterval
        }</span>

        <span class="cov8" title="1">return createConfigAnnotations(cfg)</span>
}

// Convert the provided config to node annotations
func createConfigAnnotations(cfg api.UpgradedConfig) map[string]string <span class="cov8" title="1">{
        res := make(map[string]string, 5)

        if cfg.Stream != "" </span><span class="cov8" title="1">{
                res[constants.ConfigStream] = cfg.Stream
        }</span>
        <span class="cov8" title="1">if cfg.FleetlockURL != "" </span><span class="cov8" title="1">{
                res[constants.ConfigFleetlockURL] = cfg.FleetlockURL
        }</span>
        <span class="cov8" title="1">if cfg.FleetlockGroup != "" </span><span class="cov8" title="1">{
                res[constants.ConfigFleetlockGroup] = cfg.FleetlockGroup
        }</span>
        <span class="cov8" title="1">if cfg.CheckInterval != "" </span><span class="cov8" title="1">{
                res[constants.ConfigCheckInterval] = cfg.CheckInterval
        }</span>
        <span class="cov8" title="1">if cfg.RetryInterval != "" </span><span class="cov8" title="1">{
                res[constants.ConfigRetryInterval] = cfg.RetryInterval
        }</span>

        <span class="cov8" title="1">return res</span>
}

// Apply the provided configuration annotations to the node.
// Will delete unspecified config options from node Annotations.
// Returns if the config changed.
func applyConfigAnnotations(annotations map[string]string, cfg map[string]string) bool <span class="cov8" title="1">{
        original := make(map[string]string, len(annotations))
        maps.Copy(original, annotations)

        for k := range annotations </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, constants.ConfigPrefix) </span><span class="cov8" title="1">{
                        delete(annotations, k)
                }</span>
        }

        <span class="cov8" title="1">maps.Copy(annotations, cfg)
        return !reflect.DeepEqual(original, annotations)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package controller

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
        "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/scheme"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        clientv1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/klog/v2"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        "sigs.k8s.io/controller-runtime/pkg/manager/signals"
)

func init() <span class="cov8" title="1">{
        ctrl.SetLogger(klog.NewKlogr())
}</span>

type controller struct {
        client.Client
        manager manager.Manager
        nodes   clientv1.NodeInterface
}

// Run make generate when changing these comments
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans/status,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=nodes,verbs=list;update

func NewController(name string) (*controller, error) <span class="cov8" title="1">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ns, err := GetNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(config, manager.Options{
                Scheme:                        scheme.Scheme,
                LeaderElection:                true,
                LeaderElectionNamespace:       ns,
                LeaderElectionID:              name,
                LeaderElectionReleaseOnCancel: true,
                LeaseDuration:                 Pointer(time.Minute),
                RenewDeadline:                 Pointer(10 * time.Second),
                RetryPeriod:                   Pointer(5 * time.Second),
                HealthProbeBindAddress:        ":9090",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddHealthzCheck("healthz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddReadyzCheck("readyz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;controller{
                manager: mgr,
                nodes:   client.CoreV1().Nodes(),
                Client:  mgr.GetClient(),
        }, nil</span>
}

func (c *controller) Run() error <span class="cov0" title="0">{
        err := ctrl.NewControllerManagedBy(c.manager).For(&amp;api.KubeUpgradePlan{}).Complete(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ctrl.NewWebhookManagedBy(c.manager).
                For(&amp;api.KubeUpgradePlan{}).
                WithDefaulter(&amp;planMutatingHook{}).
                WithValidator(&amp;planValidatingHook{}).
                Complete()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.manager.Start(signals.SetupSignalHandler())</span>
}

func (c *controller) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := klog.LoggerWithValues(klog.NewKlogr(), "plan", req.Name)

        var plan api.KubeUpgradePlan
        err := c.Get(ctx, req.NamespacedName, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to get Plan")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = c.reconcile(ctx, &amp;plan, logger)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = c.Status().Update(ctx, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to update plan status")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{
                Requeue:      plan.Status.Summary != api.PlanStatusComplete,
                RequeueAfter: time.Minute,
        }, nil</span>
}

func (c *controller) reconcile(ctx context.Context, plan *api.KubeUpgradePlan, logger logr.Logger) error <span class="cov8" title="1">{
        if plan.Status.Groups == nil </span><span class="cov8" title="1">{
                plan.Status.Groups = make(map[string]string, len(plan.Spec.Groups))
        }</span>

        <span class="cov8" title="1">nodesToUpdate := make(map[string][]corev1.Node, len(plan.Spec.Groups))
        newGroupStatus := make(map[string]string, len(plan.Spec.Groups))

        for name, cfg := range plan.Spec.Groups </span><span class="cov8" title="1">{
                upgradedCfg := combineConfig(plan.Spec.Upgraded, plan.Spec.Groups[name].Upgraded)

                selector, err := metav1.LabelSelectorAsSelector(cfg.Labels)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to convert labelSelector to selector for listing nodes")
                        return err
                }</span>

                <span class="cov8" title="1">nodeList, err := c.nodes.List(ctx, metav1.ListOptions{
                        LabelSelector: selector.String(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to get nodes for group")
                        return err
                }</span>

                <span class="cov8" title="1">status, update, nodes, err := c.reconcileNodes(plan.Spec.KubernetesVersion, nodeList.Items, upgradedCfg)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to reconcile nodes for group")
                        return err
                }</span>

                <span class="cov8" title="1">newGroupStatus[name] = status

                if update </span><span class="cov8" title="1">{
                        nodesToUpdate[name] = nodes
                }</span> else<span class="cov8" title="1"> if plan.Status.Groups[name] != newGroupStatus[name] </span><span class="cov8" title="1">{
                        logger.WithValues("group", name, "status", newGroupStatus[name]).Info("Group changed status")
                }</span>
        }

        <span class="cov8" title="1">for name, nodes := range nodesToUpdate </span><span class="cov8" title="1">{
                if groupWaitForDependency(plan.Spec.Groups[name].DependsOn, newGroupStatus) </span><span class="cov8" title="1">{
                        logger.WithValues("group", name).Info("Group is waiting on dependencies")
                        newGroupStatus[name] = api.PlanStatusWaiting
                        continue</span>
                } else<span class="cov8" title="1"> if plan.Status.Groups[name] != newGroupStatus[name] </span><span class="cov8" title="1">{
                        logger.WithValues("group", name, "status", newGroupStatus[name]).Info("Group changed status")
                }</span>

                <span class="cov8" title="1">for _, node := range nodes </span><span class="cov8" title="1">{
                        _, err := c.nodes.Update(ctx, &amp;node, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update node %s: %v", node.GetName(), err)
                        }</span>
                }
        }

        <span class="cov8" title="1">plan.Status.Groups = newGroupStatus
        plan.Status.Summary = createStatusSummary(plan.Status.Groups)

        return nil</span>
}

func (c *controller) reconcileNodes(kubeVersion string, nodes []corev1.Node, cfgAnnotations map[string]string) (string, bool, []corev1.Node, error) <span class="cov8" title="1">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return api.PlanStatusUnknown, false, nil, nil
        }</span>

        <span class="cov8" title="1">completed := true
        needUpdate := false

        for i := range nodes </span><span class="cov8" title="1">{
                if nodes[i].Annotations == nil </span><span class="cov8" title="1">{
                        nodes[i].Annotations = make(map[string]string)
                }</span>

                <span class="cov8" title="1">if applyConfigAnnotations(nodes[i].Annotations, cfgAnnotations) </span><span class="cov8" title="1">{
                        needUpdate = true
                }</span>

                <span class="cov8" title="1">if nodes[i].Annotations[constants.NodeKubernetesVersion] == kubeVersion </span><span class="cov8" title="1">{
                        if nodes[i].Annotations[constants.NodeUpgradeStatus] != constants.NodeUpgradeStatusCompleted </span><span class="cov0" title="0">{
                                completed = false
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">completed = false
                nodes[i].Annotations[constants.NodeKubernetesVersion] = kubeVersion
                nodes[i].Annotations[constants.NodeUpgradeStatus] = constants.NodeUpgradeStatusPending

                needUpdate = true</span>
        }

        <span class="cov8" title="1">var status string
        if completed </span><span class="cov8" title="1">{
                status = api.PlanStatusComplete
        }</span> else<span class="cov8" title="1"> {
                status = api.PlanStatusProgressing
        }</span>
        <span class="cov8" title="1">return status, needUpdate, nodes, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package controller

import "fmt"

type ErrorGetNamespace struct {
        path string
        err  error
}

func NewErrorGetNamespace(path string, err error) error <span class="cov8" title="1">{
        return &amp;ErrorGetNamespace{
                path: path,
                err:  err,
        }
}</span>

func (e *ErrorGetNamespace) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Could not retrieve namespace from \"%s\": %v", e.path, e.err)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package controller

import (
        "context"
        "fmt"

        "k8s.io/apimachinery/pkg/runtime"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
)

// +kubebuilder:webhook:path=/mutate-kubeupgrade-heathcliff-eu-v1alpha2-kubeupgradeplan,mutating=true,failurePolicy=fail,groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=create;update,versions=v1alpha2,name=kubeupgrade.heathcliff.eu,admissionReviewVersions=v1,sideEffects=None

// planMutatingHook sets the defaults for the plan
type planMutatingHook struct{}

func (*planMutatingHook) Default(_ context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        plan, ok := obj.(*api.KubeUpgradePlan)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("expected a KubeUpgradePlan but got a %T", obj)
        }</span>

        <span class="cov8" title="1">api.SetObjectDefaults_KubeUpgradePlan(plan)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package controller

import (
        "errors"
        "fmt"
        "os"
        "strings"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
)

var serviceAccountNamespaceFile = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"

const namespaceKubeUpgrade = "kube-upgrade"

// Read the namespace from the inserted serviceaccount file. Fallback to default if the file does not exist.
func GetNamespace() (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(serviceAccountNamespaceFile)
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return "", NewErrorGetNamespace(serviceAccountNamespaceFile, err)
                }</span> else<span class="cov8" title="1"> {
                        return namespaceKubeUpgrade, nil
                }</span>
        }

        <span class="cov8" title="1">ns := strings.TrimSpace(string(data))
        if len(ns) == 0 </span><span class="cov8" title="1">{
                return "", NewErrorGetNamespace(serviceAccountNamespaceFile, fmt.Errorf("file was empty"))
        }</span>
        <span class="cov8" title="1">return ns, nil</span>
}

// Return a pointer to the variable value
func Pointer[T any](v T) *T <span class="cov8" title="1">{
        return &amp;v
}</span>

// Check if the given group needs to wait on another one
func groupWaitForDependency(deps []string, status map[string]string) bool <span class="cov8" title="1">{
        for _, d := range deps </span><span class="cov8" title="1">{
                if status[d] != api.PlanStatusComplete </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Return the status summary from the given input
func createStatusSummary(status map[string]string) string <span class="cov8" title="1">{
        if len(status) == 0 </span><span class="cov8" title="1">{
                return api.PlanStatusUnknown
        }</span>
        <span class="cov8" title="1">waiting := false
        unknown := false
        progressing := false

        for _, v := range status </span><span class="cov8" title="1">{
                switch v </span>{
                case api.PlanStatusComplete:<span class="cov8" title="1"></span>
                case api.PlanStatusProgressing:<span class="cov8" title="1">
                        progressing = true</span>
                case api.PlanStatusWaiting:<span class="cov8" title="1">
                        waiting = true</span>
                default:<span class="cov8" title="1">
                        unknown = true</span>
                }
        }

        <span class="cov8" title="1">if unknown </span><span class="cov8" title="1">{
                return api.PlanStatusUnknown
        }</span> else<span class="cov8" title="1"> if progressing </span><span class="cov8" title="1">{
                return api.PlanStatusProgressing
        }</span> else<span class="cov8" title="1"> if waiting </span><span class="cov8" title="1">{
                return api.PlanStatusWaiting
        }</span> else<span class="cov8" title="1"> {
                return api.PlanStatusComplete
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controller

import (
        "context"
        "fmt"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:path=/validate-kubeupgrade-heathcliff-eu-v1alpha2-kubeupgradeplan,mutating=false,failurePolicy=fail,groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans;kubeupgradeplans/status,verbs=create;update,versions=v1alpha2,name=kubeupgrade.heathcliff.eu,admissionReviewVersions=v1,sideEffects=None

// planValidatingHook validates the plan
type planValidatingHook struct{}

// Validate all values of the plan and check if they are sensible
func (*planValidatingHook) validate(obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        plan, ok := obj.(*api.KubeUpgradePlan)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expected a KubeUpgradePlan but got a %T", obj)
        }</span>

        <span class="cov8" title="1">err := api.ValidateObject_KubeUpgradePlan(plan)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

// ValidateCreate validates the object on creation.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (p *planValidatingHook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        return p.validate(obj)
}</span>

// ValidateUpdate validates the object on update.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (p *planValidatingHook) ValidateUpdate(_ context.Context, _ runtime.Object, newObj runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        return p.validate(newObj)
}</span>

// ValidateDelete validates the object on deletion.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (*planValidatingHook) ValidateDelete(_ context.Context, _ runtime.Object) (admission.Warnings, error) <span class="cov8" title="1">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package upgradecontroller

import (
        "github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller"
        "github.com/heathcliff26/kube-upgrade/pkg/version"
        "k8s.io/klog/v2"

        "github.com/spf13/cobra"
)

const Name = "upgrade-controller"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgradeController()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to execute command: %v", err)
        }</span>
}

func NewUpgradeController() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " runs the controller to orchestrate cluster wide kubernetes upgrades.",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        run()
                        return nil
                }</span>,
        }

        <span class="cov8" title="1">rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run() <span class="cov0" title="0">{
        ctrl, err := controller.NewController(Name)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to create controller: %v", err)
        }</span>
        <span class="cov0" title="0">err = ctrl.Run()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Controller exited with error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package config

import (
        "log/slog"
        "os"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

const (
        DEFAULT_CONFIG_PATH = "/etc/kube-upgraded/config.yaml"

        DEFAULT_LOG_LEVEL       = "info"
        DEFAULT_KUBECONFIG      = "/etc/kubernetes/kubelet.conf"
        DEFAULT_STREAM          = "ghcr.io/heathcliff26/fcos-k8s"
        DEFAULT_FLEETLOCK_GROUP = "default"
        DEFAULT_RPM_OSTREE_PATH = "/usr/bin/rpm-ostree"
        DEFAULT_KUBEADM_PATH    = "/usr/bin/kubeadm"
        DEFAULT_CHECK_INTERVAL  = 3 * time.Hour
        DEFAULT_RETRY_INTERVAL  = 5 * time.Minute
)

var logLevel = &amp;slog.LevelVar{}

// Initialize the logger
func init() <span class="cov8" title="1">{
        logLevel = &amp;slog.LevelVar{}
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>

type Config struct {
        // The log level used by slog, default "info"
        LogLevel string `yaml:"logLevel,omitempty"`
        // The path to the kubeconfig file, default is the kubelet config under "/etc/kubernetes/kubelet.conf"
        Kubeconfig string `yaml:"kubeconfig,omitempty"`
        // The container image repository for os rebases
        Stream string `yaml:"stream,omitempty"`
        // Configuration for fleetlock node locking
        Fleetlock FleetlockConfig `yaml:"fleetlock"`
        // The path to the rpm-ostree binary, default "/usr/bin/rpm-ostree"
        RPMOStreePath string `yaml:"rpm-ostree-path,omitempty"`
        // The path to the kubeadm binary, default "/usr/bin/kubeadm"
        KubeadmPath string `yaml:"kubeadm-path,omitempty"`

        // The interval between regular checks, default 3h
        CheckInterval time.Duration `yaml:"check-interval,omitempty"`
        // The interval between retries when an operation fails, default 5m
        RetryInterval time.Duration `yaml:"retry-interval,omitempty"`
}

type FleetlockConfig struct {
        // URL to fleetlock server
        URL string `yaml:"url"`
        // The node group to use for fleetlock, default group is "default"
        Group string `yaml:"group,omitempty"`
}

// Parse a given string and set the resulting log level
func setLogLevel(level string) error <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="1">
                logLevel.Set(slog.LevelDebug)</span>
        case "info":<span class="cov8" title="1">
                logLevel.Set(slog.LevelInfo)</span>
        case "warn":<span class="cov8" title="1">
                logLevel.Set(slog.LevelWarn)</span>
        case "error":<span class="cov8" title="1">
                logLevel.Set(slog.LevelError)</span>
        default:<span class="cov8" title="1">
                return NewErrUnknownLogLevel(level)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                LogLevel:   DEFAULT_LOG_LEVEL,
                Kubeconfig: DEFAULT_KUBECONFIG,
                Stream:     DEFAULT_STREAM,
                Fleetlock: FleetlockConfig{
                        Group: DEFAULT_FLEETLOCK_GROUP,
                },
                RPMOStreePath: DEFAULT_RPM_OSTREE_PATH,
                KubeadmPath:   DEFAULT_KUBEADM_PATH,
                CheckInterval: DEFAULT_CHECK_INTERVAL,
                RetryInterval: DEFAULT_RETRY_INTERVAL,
        }
}</span>

// Loads the config from the given path.
// When path is empty, it checks the default path "/etc/kube-upgraded/config.yaml".
// When no config is found in the default path, it returns the default config.
// Returns error when the given config is invalid.
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        c := DefaultConfig()

        p := path
        if path == "" </span><span class="cov8" title="1">{
                p = DEFAULT_CONFIG_PATH
        }</span>

        <span class="cov8" title="1">f, err := os.ReadFile(p)
        if os.IsNotExist(err) &amp;&amp; path == "" </span><span class="cov8" title="1">{
                slog.Info("No config file specified and default file does not exist, falling back to default values.", slog.String("default-path", DEFAULT_CONFIG_PATH))
                return c, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(f, &amp;c)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = setLogLevel(c.LogLevel)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package config

type ErrUnknownLogLevel struct {
        level string
}

func NewErrUnknownLogLevel(level string) error <span class="cov8" title="1">{
        return &amp;ErrUnknownLogLevel{
                level: level,
        }
}</span>

func (e *ErrUnknownLogLevel) Error() string <span class="cov0" title="0">{
        return "Unknown log level " + e.level
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
)

// Update the daemon configuration based on the annotations of the node.
// Returns on the first error, but will change all configs before that.
func (d *daemon) UpdateConfigFromNode() error <span class="cov8" title="1">{
        node, err := d.getNode()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return d.UpdateConfigFromAnnotations(node.GetAnnotations())</span>
}

// Update the daemon configuration from the given annotations.
// Returns on the first error, but will change all configs before that.
func (d *daemon) UpdateConfigFromAnnotations(annotations map[string]string) error <span class="cov8" title="1">{
        for key, value := range annotations </span><span class="cov8" title="1">{
                switch key </span>{
                case constants.ConfigStream:<span class="cov8" title="1">
                        if value == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("stream annotation %s is empty", constants.ConfigStream)
                        }</span>
                        <span class="cov8" title="1">if d.stream != value </span><span class="cov8" title="1">{
                                slog.Info("Updated stream configuration from node annotation", slog.String("annotation", constants.ConfigStream), slog.String("value", value))
                                d.stream = value
                        }</span>
                case constants.ConfigFleetlockURL:<span class="cov8" title="1">
                        if d.fleetlock.GetURL() != value </span><span class="cov8" title="1">{
                                slog.Info("Updating fleetlock url from node annotation", slog.String("annotation", constants.ConfigFleetlockURL), slog.String("value", value))
                        }</span> else<span class="cov8" title="1"> {
                                continue</span>
                        }

                        <span class="cov8" title="1">err := d.fleetlock.SetURL(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update fleetlock url to \"%s\": %v", value, err)
                        }</span>
                case constants.ConfigFleetlockGroup:<span class="cov8" title="1">
                        if d.fleetlock.GetGroup() != value </span><span class="cov8" title="1">{
                                slog.Info("Updating fleetlock group from node annotation", slog.String("annotation", constants.ConfigFleetlockGroup), slog.String("value", value))
                        }</span> else<span class="cov8" title="1"> {
                                continue</span>
                        }

                        <span class="cov8" title="1">err := d.fleetlock.SetGroup(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update fleetlock group to \"%s\": %v", value, err)
                        }</span>
                case constants.ConfigCheckInterval:<span class="cov8" title="1">
                        interval, err := time.ParseDuration(value)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to parse \"%s\" as duration: %v", value, err)
                        }</span>
                        <span class="cov8" title="1">if d.checkInterval != interval </span><span class="cov8" title="1">{
                                slog.Info("Updated check interval from node annotation", slog.String("annotation", constants.ConfigStream), slog.String("value", value))
                                d.checkInterval = interval
                        }</span>
                case constants.ConfigRetryInterval:<span class="cov8" title="1">
                        interval, err := time.ParseDuration(value)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to parse \"%s\" as duration: %v", value, err)
                        }</span>
                        <span class="cov8" title="1">if d.retryInterval != interval </span><span class="cov8" title="1">{
                                slog.Info("Updated retry interval from node annotation", slog.String("annotation", constants.ConfigStream), slog.String("value", value))
                                d.retryInterval = interval
                        }</span>
                default:<span class="cov8" title="1">
                        continue</span>
                }
        }

        <span class="cov8" title="1">if d.fleetlock.GetURL() == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("missing fleetlock server url")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/fleetlock"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm"
        rpmostree "github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/clientcmd"
)

type daemon struct {
        fleetlock     *fleetlock.FleetlockClient
        checkInterval time.Duration
        retryInterval time.Duration

        rpmostree *rpmostree.RPMOStreeCMD
        kubeadm   *kubeadm.KubeadmCMD

        stream string
        node   string

        client kubernetes.Interface
        ctx    context.Context
        cancel context.CancelFunc

        upgrade sync.Mutex
}

// Create a new daemon
func NewDaemon(cfg *config.Config) (*daemon, error) <span class="cov8" title="1">{
        var err error
        var fleetlockClient *fleetlock.FleetlockClient
        if cfg.Fleetlock.URL != "" </span><span class="cov8" title="1">{
                slog.Debug("Creating fleetlock client with url", slog.String("url", cfg.Fleetlock.URL))
                fleetlockClient, err = fleetlock.NewClient(cfg.Fleetlock.URL, cfg.Fleetlock.Group)
        }</span> else<span class="cov8" title="1"> {
                slog.Debug("Creating fleetlock client without url")
                fleetlockClient, err = fleetlock.NewEmptyClient()
                if err != nil &amp;&amp; cfg.Fleetlock.Group != "" </span><span class="cov0" title="0">{
                        err = fleetlockClient.SetGroup(cfg.Fleetlock.Group)
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create fleetlock client: %v", err)
        }</span>

        <span class="cov8" title="1">rpmOstreeCMD, err := rpmostree.New(cfg.RPMOStreePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create rpm-ostree cmd wrapper: %v", err)
        }</span>
        <span class="cov8" title="1">kubeadmCMD, err := kubeadm.New(cfg.KubeadmPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create kubeadm cmd wrapper: %v", err)
        }</span>

        <span class="cov8" title="1">if cfg.Kubeconfig == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no kubeconfig provided")
        }</span>
        <span class="cov8" title="1">config, err := clientcmd.BuildConfigFromFlags("", cfg.Kubeconfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read kubeconfig: %v", err)
        }</span>
        <span class="cov8" title="1">kubeClient, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %v", err)
        }</span>

        <span class="cov8" title="1">if cfg.Stream == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no image stream provided for kubernetes updates")
        }</span>

        <span class="cov8" title="1">machineID, err := utils.GetMachineID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get machine-id: %v", err)
        }</span>
        <span class="cov8" title="1">node, err := findNodeByMachineID(kubeClient, machineID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get kubernetes node name for host: %v", err)
        }</span>
        <span class="cov0" title="0">slog.Info("Found node name for this host", slog.String("node", node))

        return &amp;daemon{
                fleetlock:     fleetlockClient,
                checkInterval: cfg.CheckInterval,
                retryInterval: cfg.RetryInterval,

                rpmostree: rpmOstreeCMD,
                kubeadm:   kubeadmCMD,

                stream: cfg.Stream,
                node:   node,
                client: kubeClient,
        }, nil</span>
}

// Retries the given function until it succeeds
func (d *daemon) retry(f func() bool) <span class="cov8" title="1">{
        for !f() </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(d.retryInterval):<span class="cov8" title="1"></span>
                }
        }
}

// Will try to release the lock until successfull
func (d *daemon) releaseLock() <span class="cov8" title="1">{
        d.retry(func() bool </span><span class="cov8" title="1">{
                err := d.fleetlock.Release()
                if err == nil </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov0" title="0">slog.Warn("Failed to release lock", "err", err)
                return false</span>
        })
}

// Run the main daemon loop
func (d *daemon) Run() error <span class="cov0" title="0">{
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
        ctx, cancel := context.WithCancel(context.Background())
        d.ctx = ctx
        d.cancel = cancel
        go func() </span><span class="cov0" title="0">{
                &lt;-stop
                cancel()
        }</span>()

        <span class="cov0" title="0">node, err := d.getNode()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get node status: %v", err)
        }</span>

        <span class="cov0" title="0">err = d.UpdateConfigFromAnnotations(node.GetAnnotations())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update daemon config from node annotations: %v", err)
        }</span>

        <span class="cov0" title="0">if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                slog.Debug("Releasing any log that may be held by this machine")
                d.releaseLock()
                if d.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                slog.Info("Node needs upgrade or is in the middle of one, upgrading node before starting daemon")
                d.doNodeUpgradeWithRetry(node)
        }</span>

        <span class="cov0" title="0">slog.Info("Starting daemon")

        var wg sync.WaitGroup
        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForUpgrade()
                slog.Info("Stopped watching for upgrades")
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForNodeUpgrade()
                slog.Info("Stopped watching for kubernetes upgrades")
        }</span>()

        <span class="cov0" title="0">wg.Wait()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm"
        "gopkg.in/yaml.v3"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/tools/cache"
)

// Watch for node upgrades and preform them if necessary
func (d *daemon) watchForNodeUpgrade() <span class="cov0" title="0">{
        factory := informers.NewSharedInformerFactoryWithOptions(d.client, time.Minute, informers.WithTweakListOptions(func(opts *metav1.ListOptions) </span><span class="cov0" title="0">{
                opts.FieldSelector = fields.SelectorFromSet(fields.Set{"metadata.name": d.node}).String()
        }</span>))

        <span class="cov0" title="0">informer := factory.Core().V1().Nodes().Informer()
        _, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: func(_, newObj interface{}) </span><span class="cov0" title="0">{
                        node := newObj.(*corev1.Node)
                        d.checkNodeStatus(node)
                }</span>,
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to add event handlers to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">err = informer.SetWatchErrorHandler(cache.DefaultWatchErrorHandler)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to set watch error handler to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">slog.Info("Watching for new kubernetes upgrades")
        informer.Run(d.ctx.Done())</span>
}

// Check if we need to upgrade the node and trigger the upgrade if needed
func (d *daemon) checkNodeStatus(node *corev1.Node) <span class="cov0" title="0">{
        if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d.doNodeUpgradeWithRetry(nil)</span>
}

// Update the node until it succeeds
func (d *daemon) doNodeUpgradeWithRetry(node *corev1.Node) <span class="cov0" title="0">{
        d.retry(func() bool </span><span class="cov0" title="0">{
                err := d.doNodeUpgrade(node)
                if err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">slog.Error("Failed to upgrade node", "err", err, slog.String("node", node.GetName()))
                return false</span>
        })
}

// Update the node by first rebasing to a new version and then upgrading kubernetes
func (d *daemon) doNodeUpgrade(node *corev1.Node) error <span class="cov8" title="1">{
        d.upgrade.Lock()
        defer d.upgrade.Unlock()

        var err error
        if node == nil </span><span class="cov0" title="0">{
                // Need to fetch fresh data here, as the informer might called with a stale node version
                node, err = d.getNode()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get node data from server: %v", err)
                }</span>
                <span class="cov0" title="0">if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">err = d.UpdateConfigFromAnnotations(node.GetAnnotations())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update daemon config from node annotations: %v", err)
        }</span>

        <span class="cov8" title="1">version := node.Annotations[constants.NodeKubernetesVersion]
        slog.Info("Attempting node upgrade to new kubernetes version", slog.String("node", node.GetName()), slog.String("version", version))

        err = d.fleetlock.Lock()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to aquire lock: %v", err)
        }</span>

        <span class="cov8" title="1">if version != node.Status.NodeInfo.KubeletVersion </span><span class="cov8" title="1">{
                slog.Info("Rebasing os to new kubernetes version", slog.String("version", version))
                err := d.updateNodeStatus(constants.NodeUpgradeStatusRebasing)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update node status: %v", err)
                }</span>
                <span class="cov8" title="1">err = d.rpmostree.Rebase(d.stream + ":" + version)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to rebase node: %v", err)
                }</span>
                // This return is here purely for testing, as a successfull rebase does not return, but instead reboots the system
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">slog.Info("Updating node via kubeadm")

        err = d.updateNodeStatus(constants.NodeUpgradeStatusUpgrading)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        <span class="cov0" title="0">kubeadmConfigMap, err := d.client.CoreV1().ConfigMaps("kube-system").Get(d.ctx, "kubeadm-config", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch kubeadm-config: %v", err)
        }</span>
        <span class="cov0" title="0">if kubeadmConfigMap.Data == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubeadm configmap contains no data")
        }</span>
        <span class="cov0" title="0">var kubeadmConfig kubeadm.ClusterConfiguration
        err = yaml.Unmarshal([]byte(kubeadmConfigMap.Data["ClusterConfiguration"]), &amp;kubeadmConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse kubeadm-config: %v", err)
        }</span>

        <span class="cov0" title="0">if version != kubeadmConfig.KubernetesVersion </span><span class="cov0" title="0">{
                slog.Info("kubeadm-config kubernetesVersion does not match requested version, initializing upgrade", slog.String("kubernetesVersion", kubeadmConfig.KubernetesVersion), slog.String("version", version))
                err = d.kubeadm.Apply(version)
        }</span> else<span class="cov0" title="0"> {
                slog.Debug("Cluster upgrade is already initialized, upgrading node")
                err = d.kubeadm.Node()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed run kubeadm: %v", err)
        }</span>

        <span class="cov0" title="0">err = d.updateNodeStatus(constants.NodeUpgradeStatusCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        <span class="cov0" title="0">slog.Info("Finished node upgrade, releasing lock")
        d.releaseLock()
        return nil</span>
}

// Update the kube-upgrade node status annotation with the given status
func (d *daemon) updateNodeStatus(status string) error <span class="cov8" title="1">{
        node, err := d.getNode()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if node.Annotations == nil </span><span class="cov8" title="1">{
                node.Annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">node.Annotations[constants.NodeUpgradeStatus] = status

        _, err = d.client.CoreV1().Nodes().Update(d.ctx, node, metav1.UpdateOptions{})
        if err == nil </span><span class="cov8" title="1">{
                slog.Debug("Set node status", slog.String("status", status))
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Retrieve the node from the API
func (d *daemon) getNode() (*corev1.Node, error) <span class="cov8" title="1">{
        return d.client.CoreV1().Nodes().Get(d.ctx, d.node, metav1.GetOptions{})
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"
)

// Check for os upgrades and perform them if necessary.
// Runs until context is cancelled
func (d *daemon) watchForUpgrade() <span class="cov0" title="0">{
        var needUpgrade bool
        for </span><span class="cov0" title="0">{
                d.retry(func() bool </span><span class="cov0" title="0">{
                        var err error
                        slog.Debug("Checking for upgrades via rpm-ostree")
                        needUpgrade, err = d.rpmostree.CheckForUpgrade()
                        if err == nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">slog.Error("Failed to check if there is a new upgrade", "err", err)
                        return false</span>
                })

                <span class="cov0" title="0">if needUpgrade </span><span class="cov0" title="0">{
                        slog.Info("New upgrade is necessary, trying to start update")
                        d.retry(func() bool </span><span class="cov0" title="0">{
                                err := d.doUpgrade()
                                if err == nil </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                                <span class="cov0" title="0">slog.Error("Failed to perform rpm-ostree upgrade", "err", err)
                                return false</span>
                        })
                } else<span class="cov0" title="0"> {
                        slog.Debug("No upgrades found")
                }</span>

                <span class="cov0" title="0">select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(d.checkInterval):<span class="cov0" title="0"></span>
                }
        }
}

// Perform rpm-ostree upgrade
func (d *daemon) doUpgrade() error <span class="cov8" title="1">{
        d.upgrade.Lock()
        defer d.upgrade.Unlock()

        err := d.UpdateConfigFromNode()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update daemon config from node annotations: %v", err)
        }</span>

        <span class="cov8" title="1">err = d.fleetlock.Lock()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to aquire lock: %v", err)
        }</span>

        <span class="cov8" title="1">err = d.rpmostree.Upgrade()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // This should not be reached, as rpmostree.Upgrade() reboots the node on success.
        // I included it here mainly for completness sake.

        <span class="cov8" title="1">d.releaseLock()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

// Find the node by it's machine ID
func findNodeByMachineID(client kubernetes.Interface, machineID string) (string, error) <span class="cov8" title="1">{
        nodes, err := client.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, node := range nodes.Items </span><span class="cov8" title="1">{
                if node.Status.NodeInfo.MachineID == machineID </span><span class="cov8" title="1">{
                        return node.GetName(), nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("found no node with matching machineID: %s", machineID)</span>
}

// Check if the node needs to upgrade it's kubernetes version
func nodeNeedsUpgrade(node *corev1.Node) bool <span class="cov8" title="1">{
        if node.Annotations == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">status := node.Annotations[constants.NodeUpgradeStatus]
        if status == constants.NodeUpgradeStatusCompleted </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if _, ok := node.Annotations[constants.NodeKubernetesVersion]; !ok </span><span class="cov8" title="1">{
                slog.Warn("Missing version annotation on node", slog.String("node", node.GetName()), slog.String("annotation", constants.NodeKubernetesVersion))
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package fleetlock

import (
        "fmt"
        "net/http"
        "sync"

        "github.com/heathcliff26/fleetlock/pkg/server/client"
)

type FleetlockClient struct {
        url   string
        group string
        appID string

        mutex sync.RWMutex
}

// Create a new client for fleetlock
func NewClient(url, group string) (*FleetlockClient, error) <span class="cov8" title="1">{
        c, err := NewEmptyClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = c.SetURL(url)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = c.SetGroup(group)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

// Create a new fleetlock client without url or group set
func NewEmptyClient() (*FleetlockClient, error) <span class="cov8" title="1">{
        appID, err := GetZincateAppID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create zincati app id: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;FleetlockClient{
                appID: appID,
        }, nil</span>
}

// Aquire a lock for this machine
func (c *FleetlockClient) Lock() error <span class="cov8" title="1">{
        ok, res, err := c.doRequest("/v1/pre-reboot")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("failed to aquire lock kind=\"%s\" reason=\"%s\"", res.Kind, res.Value)</span>
}

// Release the hold lock
func (c *FleetlockClient) Release() error <span class="cov8" title="1">{
        ok, res, err := c.doRequest("/v1/steady-state")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("failed to release lock kind=\"%s\" reason=\"%s\"", res.Kind, res.Value)</span>
}

func (c *FleetlockClient) doRequest(path string) (bool, client.FleetLockResponse, error) <span class="cov8" title="1">{
        c.mutex.RLock()
        defer c.mutex.RUnlock()

        body, err := client.PrepareRequest(c.group, c.appID)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("failed to prepare request body: %v", err)
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodPost, c.url+path, body)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("failed to create http post request: %v", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("fleet-lock-protocol", "true")
        req.Header.Set("Content-Type", "application/json")

        res, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("failed to send request to server: %v", err)
        }</span>

        <span class="cov8" title="1">resBody, err := client.ParseResponse(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return false, client.FleetLockResponse{}, fmt.Errorf("failed to prepare response body: %v", err)
        }</span>

        <span class="cov8" title="1">return res.StatusCode == http.StatusOK, resBody, nil</span>
}

// Get the fleetlock server url
func (c *FleetlockClient) GetURL() string <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">c.mutex.RLock()
        defer c.mutex.RUnlock()

        return c.url</span>
}

// Change the fleetlock server url
func (c *FleetlockClient) SetURL(url string) error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if url == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("the fleetlock server url can't be empty")
        }</span>
        <span class="cov8" title="1">c.url = TrimTrailingSlash(url)
        return nil</span>
}

// Get the fleetlock group
func (c *FleetlockClient) GetGroup() string <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">c.mutex.RLock()
        defer c.mutex.RUnlock()

        return c.group</span>
}

// Change the fleetlock group
func (c *FleetlockClient) SetGroup(group string) error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if group == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("the fleetlock group can't be empty")
        }</span>
        <span class="cov8" title="1">c.group = group
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package fleetlock

import (
        "strings"

        systemdutils "github.com/heathcliff26/fleetlock/pkg/systemd-utils"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
        "k8s.io/klog/v2"
)

// Find the machine-id of the current node and generate a zincati appID from it.
func GetZincateAppID() (string, error) <span class="cov8" title="1">{
        machineID, err := utils.GetMachineID()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">appID, err := systemdutils.ZincatiMachineID(machineID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return appID, nil</span>
}

// When having // in a URL, it somehow converts the request from POST to GET.
// See: https://github.com/golang/go/issues/69063
// In general it could lead to unintended behaviour.
func TrimTrailingSlash(url string) string <span class="cov8" title="1">{
        res, found := strings.CutSuffix(url, "/")
        if found </span><span class="cov8" title="1">{
                klog.Warning("Removed trailing slash in URL, as this could lead to undefined behaviour")
        }</span>
        <span class="cov8" title="1">return res</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package kubeadm

import (
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type KubeadmCMD struct {
        binary string
        mutex  sync.Mutex
}

// Create a new wrapper for kubeadm
func New(path string) (*KubeadmCMD, error) <span class="cov8" title="1">{
        err := utils.CheckExistsAndIsExecutable(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;KubeadmCMD{
                binary: path,
        }, nil</span>
}

// Run kubeadm upgrade apply
func (k *KubeadmCMD) Apply(version string) error <span class="cov8" title="1">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateCMDWithStdout(k.binary, "upgrade", "apply", "--yes", version).Run()
}</span>

// Run kubeadm upgrade node
func (k *KubeadmCMD) Node() error <span class="cov0" title="0">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateCMDWithStdout(k.binary, "upgrade", "node").Run()
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package upgraded

import (
        "log/slog"
        "os"
        "os/user"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon"
        "github.com/heathcliff26/kube-upgrade/pkg/version"

        "github.com/spf13/cobra"
)

const Name = "upgraded"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgraded()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Command exited with error", "err", err)
                os.Exit(1)
        }</span>
}

func NewUpgraded() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " daemon for keeping the system up-to-date",
                Run: func(cmd *cobra.Command, _ []string) </span><span class="cov0" title="0">{
                        cfg, err := cmd.Flags().GetString("config")
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to parse config file flag", "err", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">run(cfg)</span>
                },
        }

        <span class="cov8" title="1">rootCmd.Flags().StringP("config", "c", "", "Path to config file")
        rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run(cfgPath string) <span class="cov0" title="0">{
        cfg, err := config.LoadConfig(cfgPath)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load config file", "err", err, slog.String("path", cfgPath))
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">u, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to check if running as root", "err", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if u.Username != "root" </span><span class="cov0" title="0">{
                slog.Error("Need to be root")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">d, err := daemon.NewDaemon(cfg)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create a new daemon", "err", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = d.Run()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Daemon exited with error", "err", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package rpmostree

import (
        "fmt"
        "os/exec"
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type RPMOStreeCMD struct {
        binary string
        mutex  sync.Mutex
}

// Create a new wrapper for rpm-ostree
func New(path string) (*RPMOStreeCMD, error) <span class="cov8" title="1">{
        err := utils.CheckExistsAndIsExecutable(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;RPMOStreeCMD{
                binary: path,
        }, nil</span>
}

// Run rpm-ostree and check for new updates
func (r *RPMOStreeCMD) CheckForUpgrade() (bool, error) <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        cmd := exec.Command(r.binary, "upgrade", "--check")
        out, err := cmd.CombinedOutput()
        code, ok := getExitCode(err)
        if !ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                fmt.Println(string(out))
                return false, err
        }</span> else<span class="cov8" title="1"> if err == nil </span><span class="cov8" title="1">{
                code = 0
        }</span>

        <span class="cov8" title="1">switch code </span>{
        case 0:<span class="cov8" title="1">
                return true, nil</span>
        case 77:<span class="cov8" title="1">
                return false, nil</span>
        default:<span class="cov8" title="1">
                fmt.Println(string(out))
                return false, fmt.Errorf("rpm-ostree exited with unknown exit code %d", code)</span>
        }
}

// Upgrade the system using rpm-ostree. Writes command output to stdout/stderr.
//
// WARNING: Will reboot the system when successfull.
func (r *RPMOStreeCMD) Upgrade() error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "upgrade", "--reboot").Run()
}</span>

// Rebases the system to the given container image
//
// WARNING: Will reboot the system when successfull.
func (r *RPMOStreeCMD) Rebase(image string) error <span class="cov8" title="1">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "rebase", "--reboot", "ostree-unverified-registry:"+image).Run()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package rpmostree

import (
        "os/exec"
)

// Try to extract the exit code from the error.
func getExitCode(err error) (int, bool) <span class="cov8" title="1">{
        if exiterr, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                return exiterr.ExitCode(), true
        }</span>
        <span class="cov8" title="1">return 0, false</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package utils

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
)

// Read the machine-id from /etc/machine-id
func GetMachineID() (string, error) <span class="cov8" title="1">{
        b, err := os.ReadFile("/etc/machine-id")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">machineID := strings.TrimRight(string(b), "\r\n")
        return machineID, nil</span>
}

// Create a command that writes to stdout/stderr
func CreateCMDWithStdout(name string, arg ...string) *exec.Cmd <span class="cov8" title="1">{
        cmd := exec.Command(name, arg...)
        cmd.Stderr = os.Stderr
        cmd.Stdout = os.Stdout
        return cmd
}</span>

// Check if the given file exists and is executable
func CheckExistsAndIsExecutable(path string) error <span class="cov8" title="1">{
        f, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if f.Mode().Perm()&amp;0100 == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%s is not an executable", path)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package version

import (
        "fmt"
        "runtime"
        "runtime/debug"

        "github.com/spf13/cobra"
)

var version = "devel"

func NewCommand(name string) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information and exit",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Print(Version(name))
                }</span>,
        }
        // Override to prevent parent function from running
        <span class="cov8" title="1">cmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span>{<span class="cov0" title="0">}</span>

        <span class="cov8" title="1">return cmd</span>
}

func Version(name string) string <span class="cov8" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov0" title="0">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span> else<span class="cov8" title="1"> if commit == "" </span><span class="cov8" title="1">{
                commit = "Unknown"
        }</span>

        <span class="cov8" title="1">result := name + ":\n"
        result += "    Version: " + version + "\n"
        result += "    Commit:  " + commit + "\n"
        result += "    Go:      " + runtime.Version() + "\n"

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
