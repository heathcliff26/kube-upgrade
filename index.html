
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/defaults.go (0.0%)</option>
				
				<option value="file1">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/register.go (83.3%)</option>
				
				<option value="file2">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha1/validation.go (0.0%)</option>
				
				<option value="file3">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/defaults.go (0.0%)</option>
				
				<option value="file4">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/register.go (83.3%)</option>
				
				<option value="file5">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha2/validation.go (0.0%)</option>
				
				<option value="file6">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3/defaults.go (100.0%)</option>
				
				<option value="file7">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3/register.go (83.3%)</option>
				
				<option value="file8">github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3/validation.go (100.0%)</option>
				
				<option value="file9">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/config.go (100.0%)</option>
				
				<option value="file10">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/controller.go (68.2%)</option>
				
				<option value="file11">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/errors.go (50.0%)</option>
				
				<option value="file12">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/mutatingwebhook.go (100.0%)</option>
				
				<option value="file13">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/upgraded.go (94.7%)</option>
				
				<option value="file14">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/utils.go (97.7%)</option>
				
				<option value="file15">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller/validatingwebhook.go (100.0%)</option>
				
				<option value="file16">github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/root.go (23.5%)</option>
				
				<option value="file17">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/config.go (97.7%)</option>
				
				<option value="file18">github.com/heathcliff26/kube-upgrade/pkg/upgraded/config/errors.go (50.0%)</option>
				
				<option value="file19">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/config.go (81.2%)</option>
				
				<option value="file20">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/daemon.go (47.0%)</option>
				
				<option value="file21">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/node.go (45.5%)</option>
				
				<option value="file22">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/stream.go (32.3%)</option>
				
				<option value="file23">github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon/utils.go (71.4%)</option>
				
				<option value="file24">github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm/kubeadm.go (75.0%)</option>
				
				<option value="file25">github.com/heathcliff26/kube-upgrade/pkg/upgraded/root.go (16.1%)</option>
				
				<option value="file26">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/rpm-ostree.go (92.9%)</option>
				
				<option value="file27">github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree/utils.go (100.0%)</option>
				
				<option value="file28">github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils/utils.go (94.4%)</option>
				
				<option value="file29">github.com/heathcliff26/kube-upgrade/pkg/version/version.go (81.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package v1alpha1

const (
        DefaultStatus = "Unknown"
)

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov0" title="0">{
        if spec.Groups == nil </span><span class="cov0" title="0">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                if group.Labels == nil </span><span class="cov0" title="0">{
                        group.Labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">spec.Groups[name] = group</span>
        }
        <span class="cov0" title="0">if spec.Upgraded != nil </span><span class="cov0" title="0">{
                SetObjectDefaults_UpgradedConfig(spec.Upgraded)
        }</span>
}

func SetObjectDefaults_UpgradedConfig(cfg *UpgradedConfig) <span class="cov0" title="0">{
        if cfg.Stream == "" </span><span class="cov0" title="0">{
                cfg.Stream = "ghcr.io/heathcliff26/fcos-k8s"
        }</span>
        <span class="cov0" title="0">if cfg.FleetlockGroup == "" </span><span class="cov0" title="0">{
                cfg.FleetlockGroup = "default"
        }</span>
        <span class="cov0" title="0">if cfg.CheckInterval == "" </span><span class="cov0" title="0">{
                cfg.CheckInterval = "3h"
        }</span>
        <span class="cov0" title="0">if cfg.RetryInterval == "" </span><span class="cov0" title="0">{
                cfg.RetryInterval = "5m"
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha1",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov10" title="2">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(addKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov10" title="2">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package v1alpha1

import (
        "fmt"
        "net/url"
        "regexp"
        "slices"
        "time"
)

var (
        validStatusValues = []string{"Unknown", "Waiting", "Progressing", "Complete"}
)

func ValidateObject_KubeUpgradePlan(plan *KubeUpgradePlan) error <span class="cov0" title="0">{
        err := ValidateObject_KubeUpgradeSpec(plan.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ValidateObject_KubeUpgradeStatus(plan.Status)</span>
}

func ValidateObject_KubeUpgradeSpec(spec KubeUpgradeSpec) error <span class="cov0" title="0">{
        versionRegex := regexp.MustCompile(`^v[0-9]+\.[0-9]+\.[0-9]+$`)
        if !versionRegex.MatchString(spec.KubernetesVersion) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" is not a valid version", spec.KubernetesVersion)
        }</span>

        <span class="cov0" title="0">if len(spec.Groups) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("need at least one node group for upgrades")
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                for _, dependency := range group.DependsOn </span><span class="cov0" title="0">{
                        if _, ok := spec.Groups[dependency]; !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("group \"%s\" depends on non-existing group \"%s\"", name, dependency)
                        }</span>
                }
                <span class="cov0" title="0">if len(group.Labels) &lt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("group \"%s\" needs at least one label", name)
                }</span>
                <span class="cov0" title="0">err := ValidateObject_UpgradedConfig(group.Upgraded)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("group \"%s\" has an invalid upgraded config: %v", name, err)
                }</span>
        }

        <span class="cov0" title="0">err := ValidateObject_UpgradedConfig(spec.Upgraded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if spec.Upgraded != nil &amp;&amp; spec.Upgraded.FleetlockURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter spec.upgraded.fleetlock-url")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateObject_UpgradedConfig(cfg *UpgradedConfig) error <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if cfg.Stream != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI("http://" + cfg.Stream)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for stream: %v", cfg.Stream, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.FleetlockURL != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI(cfg.FleetlockURL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for fleetlock-url: %v", cfg.FleetlockURL, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.CheckInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.CheckInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for check-interval: %v", cfg.CheckInterval, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.RetryInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.RetryInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for retry-interval: %v", cfg.RetryInterval, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func ValidateObject_KubeUpgradeStatus(status KubeUpgradeStatus) error <span class="cov0" title="0">{
        // Mutating/Validation webhooks for subresources are called later, so it is ok if the status does not exist
        if status.Summary == "" &amp;&amp; len(status.Groups) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !slices.Contains(validStatusValues, status.Summary) </span><span class="cov0" title="0">{
                return fmt.Errorf("found unknown status \"%s\" in summary, accepted values are: %v", status.Summary, validStatusValues)
        }</span>

        <span class="cov0" title="0">for group, value := range status.Groups </span><span class="cov0" title="0">{
                if !slices.Contains(validStatusValues, value) </span><span class="cov0" title="0">{
                        return fmt.Errorf("found unknown status \"%s\" in group \"%s\", accepted values are: %v", value, group, validStatusValues)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package v1alpha2

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

const (
        DefaultStatus                 = "Unknown"
        DefaultUpgradedStream         = "ghcr.io/heathcliff26/fcos-k8s"
        DefaultUpgradedFleetlockGroup = "default"
        DefaultUpgradedCheckInterval  = "3h"
        DefaultUpgradedRetryInterval  = "1m"
)

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov0" title="0">{
        if spec.Groups == nil </span><span class="cov0" title="0">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                if group.Labels == nil </span><span class="cov0" title="0">{
                        group.Labels = &amp;metav1.LabelSelector{}
                }</span>
                <span class="cov0" title="0">spec.Groups[name] = group</span>
        }
        <span class="cov0" title="0">SetObjectDefaults_UpgradedConfig(&amp;spec.Upgraded)</span>
}

func SetObjectDefaults_UpgradedConfig(cfg *UpgradedConfig) <span class="cov0" title="0">{
        if cfg.Stream == "" </span><span class="cov0" title="0">{
                cfg.Stream = DefaultUpgradedStream
        }</span>
        <span class="cov0" title="0">if cfg.FleetlockGroup == "" </span><span class="cov0" title="0">{
                cfg.FleetlockGroup = DefaultUpgradedFleetlockGroup
        }</span>
        <span class="cov0" title="0">if cfg.CheckInterval == "" </span><span class="cov0" title="0">{
                cfg.CheckInterval = DefaultUpgradedCheckInterval
        }</span>
        <span class="cov0" title="0">if cfg.RetryInterval == "" </span><span class="cov0" title="0">{
                cfg.RetryInterval = DefaultUpgradedRetryInterval
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package v1alpha2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha2",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov10" title="2">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(AddKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func AddKnownTypes(scheme *runtime.Scheme) error <span class="cov10" title="2">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package v1alpha2

import (
        "fmt"
        "net/url"
        "time"

        "golang.org/x/mod/semver"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func ValidateObject_KubeUpgradePlan(plan *KubeUpgradePlan) error <span class="cov0" title="0">{
        return ValidateObject_KubeUpgradeSpec(plan.Spec)
}</span>

func ValidateObject_KubeUpgradeSpec(spec KubeUpgradeSpec) error <span class="cov0" title="0">{
        if !semver.IsValid(spec.KubernetesVersion) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" is not a valid semantic version", spec.KubernetesVersion)
        }</span>
        <span class="cov0" title="0">if semver.Prerelease(spec.KubernetesVersion) == "" &amp;&amp; semver.Canonical(spec.KubernetesVersion) != spec.KubernetesVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" needs to be a full version like vX.Y.Z", spec.KubernetesVersion)
        }</span>

        <span class="cov0" title="0">if len(spec.Groups) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("need at least one node group for upgrades")
        }</span>
        <span class="cov0" title="0">for name, group := range spec.Groups </span><span class="cov0" title="0">{
                for _, dependency := range group.DependsOn </span><span class="cov0" title="0">{
                        if _, ok := spec.Groups[dependency]; !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("group \"%s\" depends on non-existing group \"%s\"", name, dependency)
                        }</span>
                }

                <span class="cov0" title="0">if group.Labels == nil || (len(group.Labels.MatchExpressions) &lt; 1 &amp;&amp; len(group.Labels.MatchLabels) &lt; 1) </span><span class="cov0" title="0">{
                        return fmt.Errorf("group \"%s\" needs at least one label selector", name)
                }</span>
                <span class="cov0" title="0">_, err := metav1.LabelSelectorAsSelector(group.Labels)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid label selector for group \"%s\": %v", name, err)
                }</span>

                <span class="cov0" title="0">if group.Upgraded != nil </span><span class="cov0" title="0">{
                        err := ValidateObject_UpgradedConfig(*group.Upgraded)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("group \"%s\" has an invalid upgraded config: %v", name, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">err := ValidateObject_UpgradedConfig(spec.Upgraded)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if spec.Upgraded.FleetlockURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing parameter spec.upgraded.fleetlock-url")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateObject_UpgradedConfig(cfg UpgradedConfig) error <span class="cov0" title="0">{
        if cfg.Stream != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI("http://" + cfg.Stream)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for stream: %v", cfg.Stream, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.FleetlockURL != "" </span><span class="cov0" title="0">{
                _, err := url.ParseRequestURI(cfg.FleetlockURL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for fleetlock-url: %v", cfg.FleetlockURL, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.CheckInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.CheckInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for check-interval: %v", cfg.CheckInterval, err)
                }</span>
        }

        <span class="cov0" title="0">if cfg.RetryInterval != "" </span><span class="cov0" title="0">{
                _, err := time.ParseDuration(cfg.RetryInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid input \"%s\" for retry-interval: %v", cfg.RetryInterval, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package v1alpha3

const (
        DefaultStatus                 = "Unknown"
        DefaultUpgradedStream         = "ghcr.io/heathcliff26/fcos-k8s"
        DefaultUpgradedFleetlockGroup = "default"
        DefaultUpgradedCheckInterval  = "3h"
        DefaultUpgradedRetryInterval  = "1m"
        DefaultUpgradedLogLevel       = "info"
        DefaultUpgradedKubeletConfig  = "/etc/kubernetes/kubelet.conf"
        DefaultUpgradedKubeadmPath    = "/usr/bin/kubeadm"
)

func SetObjectDefaults_KubeUpgradeSpec(spec *KubeUpgradeSpec) <span class="cov7" title="20">{
        if spec.Groups == nil </span><span class="cov2" title="2">{
                spec.Groups = make(map[string]KubeUpgradePlanGroup)
        }</span>
        <span class="cov7" title="20">for name, group := range spec.Groups </span><span class="cov8" title="23">{
                if group.Labels == nil </span><span class="cov4" title="4">{
                        group.Labels = make(map[string]string)
                }</span>
                <span class="cov8" title="23">spec.Groups[name] = group</span>
        }
        <span class="cov7" title="20">SetObjectDefaults_UpgradedConfig(&amp;spec.Upgraded)</span>
}

func SetObjectDefaults_UpgradedConfig(cfg *UpgradedConfig) <span class="cov10" title="54">{
        if cfg.Stream == "" </span><span class="cov9" title="51">{
                cfg.Stream = DefaultUpgradedStream
        }</span>
        <span class="cov10" title="54">if cfg.FleetlockGroup == "" </span><span class="cov10" title="54">{
                cfg.FleetlockGroup = DefaultUpgradedFleetlockGroup
        }</span>
        <span class="cov10" title="54">if cfg.CheckInterval == "" </span><span class="cov9" title="52">{
                cfg.CheckInterval = DefaultUpgradedCheckInterval
        }</span>
        <span class="cov10" title="54">if cfg.RetryInterval == "" </span><span class="cov9" title="52">{
                cfg.RetryInterval = DefaultUpgradedRetryInterval
        }</span>
        <span class="cov10" title="54">if cfg.LogLevel == "" </span><span class="cov10" title="54">{
                cfg.LogLevel = DefaultUpgradedLogLevel
        }</span>
        <span class="cov10" title="54">if cfg.KubeletConfig == "" </span><span class="cov10" title="54">{
                cfg.KubeletConfig = DefaultUpgradedKubeletConfig
        }</span>
        <span class="cov10" title="54">if cfg.KubeadmPath == "" </span><span class="cov10" title="54">{
                cfg.KubeadmPath = DefaultUpgradedKubeadmPath
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Define your schema name and the version
var SchemeGroupVersion = schema.GroupVersion{
        Group:   "kubeupgrade.heathcliff.eu",
        Version: "v1alpha3",
}

var (
        SchemeBuilder      runtime.SchemeBuilder
        localSchemeBuilder = &amp;SchemeBuilder
        AddToScheme        = localSchemeBuilder.AddToScheme
)

func init() <span class="cov5" title="5">{
        // We only register manually written functions here. The registration of the
        // generated functions takes place in the generated files. The separation
        // makes the code compile even when the generated files are missing.
        localSchemeBuilder.Register(AddKnownTypes)
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// Adds the list of known types to the given scheme.
func AddKnownTypes(scheme *runtime.Scheme) error <span class="cov10" title="20">{
        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;KubeUpgradePlan{},
                &amp;KubeUpgradePlanList{},
        )

        scheme.AddKnownTypes(
                SchemeGroupVersion,
                &amp;metav1.Status{},
        )

        metav1.AddToGroupVersion(
                scheme,
                SchemeGroupVersion,
        )

        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package v1alpha3

import (
        "fmt"
        "net/url"
        "time"

        "golang.org/x/mod/semver"
)

func ValidateObject_KubeUpgradePlan(plan *KubeUpgradePlan) error <span class="cov10" title="21">{
        return ValidateObject_KubeUpgradeSpec(plan.Spec)
}</span>

func ValidateObject_KubeUpgradeSpec(spec KubeUpgradeSpec) error <span class="cov10" title="21">{
        if !semver.IsValid(spec.KubernetesVersion) </span><span class="cov5" title="5">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" is not a valid semantic version", spec.KubernetesVersion)
        }</span>
        <span class="cov9" title="16">if semver.Prerelease(spec.KubernetesVersion) == "" &amp;&amp; semver.Canonical(spec.KubernetesVersion) != spec.KubernetesVersion </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid input for spec.kubernetesVersion, \"%s\" needs to be a full version like vX.Y.Z", spec.KubernetesVersion)
        }</span>

        <span class="cov9" title="15">if len(spec.Groups) &lt; 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("need at least one node group for upgrades")
        }</span>
        <span class="cov8" title="14">for name, group := range spec.Groups </span><span class="cov9" title="19">{
                for _, dependency := range group.DependsOn </span><span class="cov6" title="6">{
                        if _, ok := spec.Groups[dependency]; !ok </span><span class="cov1" title="1">{
                                return fmt.Errorf("group \"%s\" depends on non-existing group \"%s\"", name, dependency)
                        }</span>
                }

                <span class="cov9" title="18">if len(group.Labels) &lt; 1 </span><span class="cov1" title="1">{
                        return fmt.Errorf("group \"%s\" needs at least one label selector", name)
                }</span>

                <span class="cov9" title="17">if group.Upgraded != nil </span><span class="cov3" title="2">{
                        err := ValidateObject_UpgradedConfig(*group.Upgraded)
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("group \"%s\" has an invalid upgraded config: %v", name, err)
                        }</span>
                }
        }

        <span class="cov8" title="11">err := ValidateObject_UpgradedConfig(spec.Upgraded)
        if err != nil </span><span class="cov5" title="4">{
                return err
        }</span>
        <span class="cov6" title="7">if spec.Upgraded.FleetlockURL == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("missing parameter spec.upgraded.fleetlockUrl")
        }</span>

        <span class="cov6" title="6">return nil</span>
}

func ValidateObject_UpgradedConfig(cfg UpgradedConfig) error <span class="cov8" title="13">{
        if cfg.Stream != "" </span><span class="cov7" title="9">{
                _, err := url.ParseRequestURI("http://" + cfg.Stream)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for stream: %v", cfg.Stream, err)
                }</span>
        }

        <span class="cov8" title="12">if cfg.FleetlockURL != "" </span><span class="cov7" title="10">{
                _, err := url.ParseRequestURI(cfg.FleetlockURL)
                if err != nil </span><span class="cov3" title="2">{
                        return fmt.Errorf("invalid input \"%s\" for fleetlockUrl: %v", cfg.FleetlockURL, err)
                }</span>
        }

        <span class="cov7" title="10">if cfg.CheckInterval != "" </span><span class="cov6" title="7">{
                _, err := time.ParseDuration(cfg.CheckInterval)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for checkInterval: %v", cfg.CheckInterval, err)
                }</span>
        }

        <span class="cov7" title="9">if cfg.RetryInterval != "" </span><span class="cov6" title="6">{
                _, err := time.ParseDuration(cfg.RetryInterval)
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid input \"%s\" for retryInterval: %v", cfg.RetryInterval, err)
                }</span>
        }

        <span class="cov7" title="8">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package controller

import (
        "strings"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
)

// Combine 2 configs, where group overrides the values used by global.
// Returns the combined configuration.
func combineConfig(global api.UpgradedConfig, group *api.UpgradedConfig) *api.UpgradedConfig <span class="cov9" title="43">{
        cfg := global
        if group == nil </span><span class="cov9" title="36">{
                return &amp;cfg
        }</span>

        <span class="cov5" title="7">if group.Stream != "" </span><span class="cov4" title="4">{
                cfg.Stream = group.Stream
        }</span>
        <span class="cov5" title="7">if group.FleetlockURL != "" </span><span class="cov3" title="3">{
                cfg.FleetlockURL = group.FleetlockURL
        }</span>
        <span class="cov5" title="7">if group.FleetlockGroup != "" </span><span class="cov5" title="6">{
                cfg.FleetlockGroup = group.FleetlockGroup
        }</span>
        <span class="cov5" title="7">if group.CheckInterval != "" </span><span class="cov4" title="4">{
                cfg.CheckInterval = group.CheckInterval
        }</span>
        <span class="cov5" title="7">if group.RetryInterval != "" </span><span class="cov4" title="4">{
                cfg.RetryInterval = group.RetryInterval
        }</span>
        <span class="cov5" title="7">if group.LogLevel != "" </span><span class="cov4" title="5">{
                cfg.LogLevel = group.LogLevel
        }</span>
        <span class="cov5" title="7">if group.KubeletConfig != "" </span><span class="cov4" title="4">{
                cfg.KubeletConfig = group.KubeletConfig
        }</span>
        <span class="cov5" title="7">if group.KubeadmPath != "" </span><span class="cov4" title="4">{
                cfg.KubeadmPath = group.KubeadmPath
        }</span>

        <span class="cov5" title="7">return &amp;cfg</span>
}

// Delete all config annotations from the node.
// Returns if the config changed.
func deleteConfigAnnotations(annotations map[string]string) bool <span class="cov9" title="39">{
        changed := false

        for k := range annotations </span><span class="cov10" title="52">{
                if strings.HasPrefix(k, constants.ConfigPrefix) </span><span class="cov7" title="20">{
                        delete(annotations, k)
                        changed = true
                }</span>
        }
        <span class="cov9" title="39">return changed</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package controller

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
        "github.com/heathcliff26/kube-upgrade/pkg/client/clientset/versioned/scheme"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        "golang.org/x/mod/semver"
        appv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/klog/v2"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/manager"
        "sigs.k8s.io/controller-runtime/pkg/manager/signals"
)

const (
        defaultUpgradedImage = "ghcr.io/heathcliff26/kube-upgraded"
        upgradedImageEnv     = "UPGRADED_IMAGE"
        upgradedTagEnv       = "UPGRADED_TAG"
)

func init() <span class="cov2" title="2">{
        ctrl.SetLogger(klog.NewKlogr())
}</span>

type controller struct {
        client.Client
        manager       manager.Manager
        client        kubernetes.Interface
        namespace     string
        upgradedImage string
}

// Run make generate when changing these comments
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans/status,verbs=get;update;patch
// +kubebuilder:rbac:groups="",resources=nodes,verbs=list;update
func NewController(name string) (*controller, error) <span class="cov1" title="1">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ns, err := GetNamespace()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(config, manager.Options{
                Scheme:                        scheme.Scheme,
                LeaderElection:                true,
                LeaderElectionNamespace:       ns,
                LeaderElectionID:              name,
                LeaderElectionReleaseOnCancel: true,
                LeaseDuration:                 Pointer(time.Minute),
                RenewDeadline:                 Pointer(10 * time.Second),
                RetryPeriod:                   Pointer(5 * time.Second),
                HealthProbeBindAddress:        ":9090",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddHealthzCheck("healthz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = mgr.AddReadyzCheck("readyz", healthz.Ping)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;controller{
                Client:        mgr.GetClient(),
                manager:       mgr,
                client:        client,
                namespace:     ns,
                upgradedImage: GetUpgradedImage(),
        }, nil</span>
}

func (c *controller) Run() error <span class="cov0" title="0">{
        err := ctrl.NewControllerManagedBy(c.manager).For(&amp;api.KubeUpgradePlan{}).Complete(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ctrl.NewWebhookManagedBy(c.manager).
                For(&amp;api.KubeUpgradePlan{}).
                WithDefaulter(&amp;planMutatingHook{}).
                WithValidator(&amp;planValidatingHook{}).
                Complete()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.manager.Start(signals.SetupSignalHandler())</span>
}

func (c *controller) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := klog.LoggerWithValues(klog.NewKlogr(), "plan", req.Name)

        var plan api.KubeUpgradePlan
        err := c.Get(ctx, req.NamespacedName, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to get Plan")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = c.reconcile(ctx, &amp;plan, logger)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = c.Status().Update(ctx, &amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to update plan status")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{
                Requeue:      plan.Status.Summary != api.PlanStatusComplete,
                RequeueAfter: time.Minute,
        }, nil</span>
}

func (c *controller) reconcile(ctx context.Context, plan *api.KubeUpgradePlan, logger logr.Logger) error <span class="cov8" title="18">{
        if plan.Status.Groups == nil </span><span class="cov6" title="10">{
                plan.Status.Groups = make(map[string]string, len(plan.Spec.Groups))
        }</span>

        <span class="cov8" title="18">if controllerutil.AddFinalizer(plan, constants.Finalizer) </span><span class="cov7" title="17">{
                err := c.Update(ctx, plan)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add finalizer to plan %s: %v", plan.Name, err)
                }</span>
        }

        <span class="cov8" title="18">cmList, err := c.client.CoreV1().ConfigMaps(c.namespace).List(ctx, metav1.ListOptions{
                LabelSelector: fmt.Sprintf("%s=%s", constants.LabelPlanName, plan.Name),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.WithValues("plan", plan.Name).Error(err, "Failed to fetch upgraded ConfigMaps")
                return err
        }</span>

        <span class="cov8" title="18">daemonsList, err := c.client.AppsV1().DaemonSets(c.namespace).List(ctx, metav1.ListOptions{
                LabelSelector: fmt.Sprintf("%s=%s", constants.LabelPlanName, plan.Name),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.WithValues("plan", plan.Name).Error(err, "Failed to fetch upgraded DaemonSets")
                return err
        }</span>

        <span class="cov8" title="18">if !plan.DeletionTimestamp.IsZero() </span><span class="cov1" title="1">{
                logger.WithValues("plan", plan.Name).Info("Plan is being deleted, cleaning up resources")
                for _, daemon := range daemonsList.Items </span><span class="cov1" title="1">{
                        err := c.client.AppsV1().DaemonSets(c.namespace).Delete(ctx, daemon.Name, metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete DaemonSet %s: %v", daemon.Name, err)
                        }</span>
                        <span class="cov1" title="1">logger.WithValues("name", daemon.Name).Info("Deleted DaemonSet")</span>
                }
                <span class="cov1" title="1">for _, cm := range cmList.Items </span><span class="cov1" title="1">{
                        err := c.client.CoreV1().ConfigMaps(c.namespace).Delete(ctx, cm.Name, metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete ConfigMap %s: %v", cm.Name, err)
                        }</span>
                        <span class="cov1" title="1">logger.WithValues("name", cm.Name).Info("Deleted ConfigMap")</span>
                }
                <span class="cov1" title="1">controllerutil.RemoveFinalizer(plan, constants.Finalizer)
                err := c.Update(ctx, plan)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove finalizer from plan %s: %v", plan.Name, err)
                }</span>
                <span class="cov1" title="1">logger.WithValues("plan", plan.Name).Info("Finished cleanup of resources")
                return nil</span>
        }

        <span class="cov7" title="17">daemons := make(map[string]appv1.DaemonSet, len(plan.Spec.Groups))
        for _, daemon := range daemonsList.Items </span><span class="cov6" title="8">{
                group := daemon.Labels[constants.LabelNodeGroup]
                if _, ok := plan.Spec.Groups[group]; ok </span><span class="cov5" title="6">{
                        daemons[group] = daemon
                }</span> else<span class="cov2" title="2"> {
                        err := c.client.AppsV1().DaemonSets(c.namespace).Delete(ctx, daemon.Name, metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete DaemonSet %s: %v", daemon.Name, err)
                        }</span>
                        <span class="cov2" title="2">logger.WithValues("name", daemon.Name).Info("Deleted obsolete DaemonSet")</span>
                }
        }

        <span class="cov7" title="17">cms := make(map[string]corev1.ConfigMap, len(plan.Spec.Groups))
        for _, cm := range cmList.Items </span><span class="cov6" title="8">{
                group := cm.Labels[constants.LabelNodeGroup]
                if _, ok := plan.Spec.Groups[group]; ok </span><span class="cov5" title="6">{
                        cms[group] = cm
                }</span> else<span class="cov2" title="2"> {
                        err := c.client.CoreV1().ConfigMaps(c.namespace).Delete(ctx, cm.Name, metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete ConfigMap %s: %v", cm.Name, err)
                        }</span>
                        <span class="cov2" title="2">logger.WithValues("name", cm.Name).Info("Deleted obsolete ConfigMap")</span>
                }
        }

        <span class="cov7" title="17">nodesToUpdate := make(map[string][]corev1.Node, len(plan.Spec.Groups))
        newGroupStatus := make(map[string]string, len(plan.Spec.Groups))

        for name, cfg := range plan.Spec.Groups </span><span class="cov9" title="37">{
                upgradedCfg := combineConfig(plan.Spec.Upgraded, plan.Spec.Groups[name].Upgraded)

                cm, ok := cms[name]
                if !ok </span><span class="cov9" title="31">{
                        cm = c.NewEmptyUpgradedConfigMap(plan.Name, name)
                }</span>
                <span class="cov9" title="37">err = c.AttachUpgradedConfigMapData(&amp;cm, upgradedCfg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to attach data to ConfigMap %s: %v", cm.Name, err)
                }</span>
                <span class="cov9" title="37">if ok </span><span class="cov5" title="6">{
                        _, err = c.client.CoreV1().ConfigMaps(c.namespace).Update(ctx, &amp;cm, metav1.UpdateOptions{})
                }</span> else<span class="cov9" title="31"> {
                        logger.WithValues("group", name, "config", cm.Name).Info("Creating upgraded ConfigMap for group")
                        _, err = c.client.CoreV1().ConfigMaps(c.namespace).Create(ctx, &amp;cm, metav1.CreateOptions{})
                }</span>
                <span class="cov9" title="37">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create/update ConfigMap %s: %v", cm.Name, err)
                }</span>

                <span class="cov9" title="37">daemon, ok := daemons[name]
                if !ok </span><span class="cov9" title="31">{
                        daemon = c.NewEmptyUpgradedDaemonSet(plan.Name, name)
                }</span>
                <span class="cov9" title="37">daemon.Spec = c.NewUpgradedDaemonSetSpec(plan.Name, name)
                daemon.Spec.Template.Spec.NodeSelector = cfg.Labels
                daemon.Spec.Template.Spec.Tolerations = cfg.Tolerations
                if ok </span><span class="cov5" title="6">{
                        _, err = c.client.AppsV1().DaemonSets(c.namespace).Update(ctx, &amp;daemon, metav1.UpdateOptions{})
                }</span> else<span class="cov9" title="31"> {
                        logger.WithValues("group", name, "daemon", daemon.Name).Info("Creating upgraded DaemonSet for group")
                        _, err = c.client.AppsV1().DaemonSets(c.namespace).Create(ctx, &amp;daemon, metav1.CreateOptions{})
                }</span>
                <span class="cov9" title="37">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create/update DaemonSet %s: %v", daemon.Name, err)
                }</span>

                <span class="cov9" title="37">nodeList, err := c.client.CoreV1().Nodes().List(ctx, metav1.ListOptions{
                        LabelSelector: labels.SelectorFromSet(cfg.Labels).String(),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to get nodes for group")
                        return err
                }</span>

                <span class="cov9" title="37">status, update, nodes, err := c.reconcileNodes(plan.Spec.KubernetesVersion, plan.Spec.AllowDowngrade, nodeList.Items)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithValues("group", name).Error(err, "Failed to reconcile nodes for group")
                        return err
                }</span>

                <span class="cov9" title="37">newGroupStatus[name] = status

                if update </span><span class="cov8" title="23">{
                        nodesToUpdate[name] = nodes
                }</span> else<span class="cov7" title="14"> if plan.Status.Groups[name] != newGroupStatus[name] </span><span class="cov6" title="10">{
                        logger.WithValues("group", name, "status", newGroupStatus[name]).Info("Group changed status")
                }</span>
        }

        <span class="cov7" title="17">for name, nodes := range nodesToUpdate </span><span class="cov8" title="23">{
                if groupWaitForDependency(plan.Spec.Groups[name].DependsOn, newGroupStatus) </span><span class="cov5" title="6">{
                        logger.WithValues("group", name).Info("Group is waiting on dependencies")
                        newGroupStatus[name] = api.PlanStatusWaiting
                        continue</span>
                } else<span class="cov7" title="17"> if plan.Status.Groups[name] != newGroupStatus[name] </span><span class="cov7" title="15">{
                        logger.WithValues("group", name, "status", newGroupStatus[name]).Info("Group changed status")
                }</span>

                <span class="cov7" title="17">for _, node := range nodes </span><span class="cov7" title="17">{
                        _, err := c.client.CoreV1().Nodes().Update(ctx, &amp;node, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update node %s: %v", node.GetName(), err)
                        }</span>
                }
        }

        <span class="cov7" title="17">plan.Status.Groups = newGroupStatus
        plan.Status.Summary = createStatusSummary(plan.Status.Groups)

        return nil</span>
}

func (c *controller) reconcileNodes(kubeVersion string, downgrade bool, nodes []corev1.Node) (string, bool, []corev1.Node, error) <span class="cov10" title="39">{
        if len(nodes) == 0 </span><span class="cov4" title="4">{
                return api.PlanStatusUnknown, false, nil, nil
        }</span>

        <span class="cov9" title="35">completed := 0
        needUpdate := false
        errorNodes := make([]string, 0)

        for i := range nodes </span><span class="cov9" title="35">{
                if nodes[i].Annotations == nil </span><span class="cov8" title="20">{
                        nodes[i].Annotations = make(map[string]string)
                }</span>

                // Step to cleanup after migration to v0.6.0
                // TODO: Remove in v0.7.0
                <span class="cov9" title="35">if deleteConfigAnnotations(nodes[i].Annotations) </span><span class="cov2" title="2">{
                        needUpdate = true
                }</span>

                <span class="cov9" title="35">if !downgrade &amp;&amp; semver.Compare(kubeVersion, nodes[i].Status.NodeInfo.KubeletVersion) &lt; 0 </span><span class="cov1" title="1">{
                        return api.PlanStatusError, false, nil, fmt.Errorf("node %s version %s is newer than %s, but downgrade is disabled", nodes[i].GetName(), nodes[i].Status.NodeInfo.KubeletVersion, kubeVersion)
                }</span>

                <span class="cov9" title="34">if nodes[i].Annotations[constants.NodeKubernetesVersion] == kubeVersion </span><span class="cov7" title="12">{
                        switch nodes[i].Annotations[constants.NodeUpgradeStatus] </span>{
                        case constants.NodeUpgradeStatusCompleted:<span class="cov6" title="11">
                                completed++</span>
                        case constants.NodeUpgradeStatusError:<span class="cov1" title="1">
                                errorNodes = append(errorNodes, nodes[i].GetName())</span>
                        }
                        <span class="cov7" title="12">continue</span>
                }

                <span class="cov8" title="22">nodes[i].Annotations[constants.NodeKubernetesVersion] = kubeVersion
                nodes[i].Annotations[constants.NodeUpgradeStatus] = constants.NodeUpgradeStatusPending

                needUpdate = true</span>
        }

        <span class="cov9" title="34">var status string
        if len(errorNodes) &gt; 0 </span><span class="cov1" title="1">{
                status = fmt.Sprintf("%s: The nodes %v are reporting errors", api.PlanStatusError, errorNodes)
        }</span> else<span class="cov9" title="33"> if len(nodes) == completed </span><span class="cov6" title="11">{
                status = api.PlanStatusComplete
        }</span> else<span class="cov8" title="22"> {
                status = fmt.Sprintf("%s: %d/%d nodes upgraded", api.PlanStatusProgressing, completed, len(nodes))
        }</span>
        <span class="cov9" title="34">return status, needUpdate, nodes, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controller

import "fmt"

type ErrorGetNamespace struct {
        path string
        err  error
}

func NewErrorGetNamespace(path string, err error) error <span class="cov8" title="1">{
        return &amp;ErrorGetNamespace{
                path: path,
                err:  err,
        }
}</span>

func (e *ErrorGetNamespace) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Could not retrieve namespace from \"%s\": %v", e.path, e.err)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package controller

import (
        "context"
        "fmt"

        "k8s.io/apimachinery/pkg/runtime"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
)

// +kubebuilder:webhook:path=/mutate-kubeupgrade-heathcliff-eu-v1alpha3-kubeupgradeplan,mutating=true,failurePolicy=fail,groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=create;update,versions=v1alpha3,name=kubeupgrade.heathcliff.eu,admissionReviewVersions=v1,sideEffects=None

// planMutatingHook sets the defaults for the plan
type planMutatingHook struct{}

func (*planMutatingHook) Default(_ context.Context, obj runtime.Object) error <span class="cov10" title="21">{
        plan, ok := obj.(*api.KubeUpgradePlan)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("expected a KubeUpgradePlan but got a %T", obj)
        }</span>

        <span class="cov9" title="20">api.SetObjectDefaults_KubeUpgradePlan(plan)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controller

import (
        "fmt"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        upgradedconfig "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        appv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/yaml"
)

// Creates a new DaemonSet with the required metadata and no spec.
func (c *controller) NewEmptyUpgradedDaemonSet(plan, group string) appv1.DaemonSet <span class="cov7" title="40">{
        labels := upgradedLabels(plan, group)

        return appv1.DaemonSet{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      fmt.Sprintf("upgraded-%s", group),
                        Namespace: c.namespace,
                        Labels:    labels,
                },
        }
}</span>

// Create a Spec template for an upgraded group.
// Caller should add node selector after creation.
// Used to override the DaemonSet on each reconciliation.
func (c *controller) NewUpgradedDaemonSetSpec(plan, group string) appv1.DaemonSetSpec <span class="cov7" title="46">{
        labels := upgradedLabels(plan, group)

        spec := appv1.DaemonSetSpec{
                Selector: &amp;metav1.LabelSelector{
                        MatchLabels: labels,
                },
                Template: corev1.PodTemplateSpec{
                        ObjectMeta: metav1.ObjectMeta{
                                Labels: labels,
                        },
                        Spec: corev1.PodSpec{
                                // Need to run with host PIDs for rpm-ostree to work.
                                // Otherwise it won't see the caller process PID.
                                HostPID: true,
                                Containers: []corev1.Container{
                                        {
                                                Name:  "upgraded",
                                                Image: c.upgradedImage,
                                                Env: []corev1.EnvVar{
                                                        {
                                                                Name: "HOSTNAME",
                                                                ValueFrom: &amp;corev1.EnvVarSource{
                                                                        FieldRef: &amp;corev1.ObjectFieldSelector{
                                                                                FieldPath: "spec.nodeName",
                                                                        },
                                                                },
                                                        },
                                                },
                                                SecurityContext: &amp;corev1.SecurityContext{
                                                        Privileged: Pointer(true),
                                                },
                                                VolumeMounts: []corev1.VolumeMount{
                                                        {
                                                                Name:      "config",
                                                                MountPath: upgradedconfig.DefaultConfigDir,
                                                        },
                                                },
                                        },
                                },
                                Volumes: []corev1.Volume{
                                        {
                                                Name: "config",
                                                VolumeSource: corev1.VolumeSource{
                                                        ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                                                LocalObjectReference: corev1.LocalObjectReference{
                                                                        Name: fmt.Sprintf("upgraded-%s", group),
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        attachVolumeMountHostPath(&amp;spec, "host-run", "/run", "/run")
        attachVolumeMountHostPath(&amp;spec, "rootfs", "/", "/host")
        // Contains certificates referenced by kubelet config.
        attachVolumeMountHostPath(&amp;spec, "kubelet-pki", "/var/lib/kubelet/pki", "/var/lib/kubelet/pki")
        // TODO: This could be dropped in favour of detecting the node name via hostname in upgraded.
        attachVolumeMountHostPath(&amp;spec, "machine-id", "/etc/machine-id", "/etc/machine-id")

        return spec
}</span>

// Creates a new ConfigMap with the required metadata and no spec.
func (c *controller) NewEmptyUpgradedConfigMap(plan, group string) corev1.ConfigMap <span class="cov7" title="40">{
        labels := upgradedLabels(plan, group)

        return corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      fmt.Sprintf("upgraded-%s", group),
                        Namespace: c.namespace,
                        Labels:    labels,
                },
        }
}</span>

// Converts the given config to a string and attaches it to the given ConfigMap data.
func (c *controller) AttachUpgradedConfigMapData(cm *corev1.ConfigMap, cfg *api.UpgradedConfig) error <span class="cov7" title="46">{
        data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert upgraded config to yaml: %v", err)
        }</span>

        <span class="cov7" title="46">cm.Data = map[string]string{upgradedconfig.DefaultConfigFile: string(data)}
        return nil</span>
}

func attachVolumeMountHostPath(spec *appv1.DaemonSetSpec, name, hostPath, mountPath string) <span class="cov10" title="184">{
        spec.Template.Spec.Volumes = append(spec.Template.Spec.Volumes, corev1.Volume{
                Name: name,
                VolumeSource: corev1.VolumeSource{
                        HostPath: &amp;corev1.HostPathVolumeSource{
                                Path: hostPath,
                        },
                },
        })
        spec.Template.Spec.Containers[0].VolumeMounts = append(spec.Template.Spec.Containers[0].VolumeMounts, corev1.VolumeMount{
                Name:      name,
                MountPath: mountPath,
        })
}</span>

func upgradedLabels(planName, groupName string) map[string]string <span class="cov9" title="130">{
        return map[string]string{
                constants.LabelPlanName:  planName,
                constants.LabelNodeGroup: groupName,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package controller

import (
        "errors"
        "fmt"
        "log/slog"
        "os"
        "strings"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
        "github.com/heathcliff26/kube-upgrade/pkg/version"
)

var serviceAccountNamespaceFile = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"

const namespaceKubeUpgrade = "kube-upgrade"

// Read the namespace from the inserted serviceaccount file. Fallback to default if the file does not exist.
func GetNamespace() (string, error) <span class="cov3" title="3">{
        data, err := os.ReadFile(serviceAccountNamespaceFile)
        if err != nil </span><span class="cov1" title="1">{
                if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return "", NewErrorGetNamespace(serviceAccountNamespaceFile, err)
                }</span> else<span class="cov1" title="1"> {
                        return namespaceKubeUpgrade, nil
                }</span>
        }

        <span class="cov2" title="2">ns := strings.TrimSpace(string(data))
        if len(ns) == 0 </span><span class="cov1" title="1">{
                return "", NewErrorGetNamespace(serviceAccountNamespaceFile, fmt.Errorf("file was empty"))
        }</span>
        <span class="cov1" title="1">return ns, nil</span>
}

// Return a pointer to the variable value
func Pointer[T any](v T) *T <span class="cov9" title="47">{
        return &amp;v
}</span>

// Check if the given group needs to wait on another one
func groupWaitForDependency(deps []string, status map[string]string) bool <span class="cov8" title="26">{
        for _, d := range deps </span><span class="cov7" title="17">{
                if status[d] != api.PlanStatusComplete </span><span class="cov5" title="7">{
                        return true
                }</span>
        }
        <span class="cov7" title="19">return false</span>
}

// Return the status summary from the given input
func createStatusSummary(status map[string]string) string <span class="cov8" title="23">{
        if len(status) == 0 </span><span class="cov1" title="1">{
                return api.PlanStatusUnknown
        }</span>
        <span class="cov8" title="22">waiting := false
        unknown := false
        progressing := make([]string, 0, len(status))
        errorGroups := make([]string, 0, len(status))

        for group, s := range status </span><span class="cov10" title="52">{
                switch </span>{
                case s == api.PlanStatusComplete:<span class="cov7" title="20"></span>
                case strings.HasPrefix(s, api.PlanStatusProgressing):<span class="cov7" title="18">
                        progressing = append(progressing, group)</span>
                case s == api.PlanStatusWaiting:<span class="cov5" title="7">
                        waiting = true</span>
                case strings.HasPrefix(s, api.PlanStatusError):<span class="cov2" title="2">
                        errorGroups = append(errorGroups, group)</span>
                default:<span class="cov4" title="5">
                        unknown = true</span>
                }
        }

        <span class="cov8" title="22">if unknown </span><span class="cov4" title="5">{
                return api.PlanStatusUnknown
        }</span> else<span class="cov7" title="17"> if len(errorGroups) &gt; 0 </span><span class="cov2" title="2">{
                return fmt.Sprintf("%s: Some groups encountered errors %v", api.PlanStatusError, errorGroups)
        }</span> else<span class="cov7" title="15"> if len(progressing) &gt; 0 </span><span class="cov6" title="10">{
                return fmt.Sprintf("%s: Upgrading groups %v", api.PlanStatusProgressing, progressing)
        }</span> else<span class="cov4" title="5"> if waiting </span><span class="cov1" title="1">{
                return api.PlanStatusWaiting
        }</span> else<span class="cov4" title="4"> {
                return api.PlanStatusComplete
        }</span>
}

// Return the upgraded image to use based on environment variables
func GetUpgradedImage() string <span class="cov4" title="4">{
        image := os.Getenv(upgradedImageEnv)
        tag := os.Getenv(upgradedTagEnv)
        if image == "" </span><span class="cov2" title="2">{
                slog.Info("Upgraded image is not set, falling back to default", slog.String("env", upgradedImageEnv), slog.String("image", defaultUpgradedImage))
                image = defaultUpgradedImage
        }</span>
        <span class="cov4" title="4">if tag == "" </span><span class="cov2" title="2">{
                slog.Info("Upgraded image tag is not set, falling back to default", slog.String("env", upgradedTagEnv), slog.String("tag", version.Version()))
                tag = version.Version()
        }</span>
        <span class="cov4" title="4">return fmt.Sprintf("%s:%s", image, tag)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package controller

import (
        "context"
        "fmt"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:webhook:path=/validate-kubeupgrade-heathcliff-eu-v1alpha3-kubeupgradeplan,mutating=false,failurePolicy=fail,groups=kubeupgrade.heathcliff.eu,resources=kubeupgradeplans,verbs=create;update,versions=v1alpha3,name=kubeupgrade.heathcliff.eu,admissionReviewVersions=v1,sideEffects=None

// planValidatingHook validates the plan
type planValidatingHook struct{}

// Validate all values of the plan and check if they are sensible
func (*planValidatingHook) validate(obj runtime.Object) (admission.Warnings, error) <span class="cov10" title="22">{
        plan, ok := obj.(*api.KubeUpgradePlan)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("expected a KubeUpgradePlan but got a %T", obj)
        }</span>

        <span class="cov9" title="21">err := api.ValidateObject_KubeUpgradePlan(plan)
        if err != nil </span><span class="cov8" title="15">{
                return nil, err
        }</span>

        <span class="cov6" title="6">return nil, nil</span>
}

// ValidateCreate validates the object on creation.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (p *planValidatingHook) ValidateCreate(_ context.Context, obj runtime.Object) (admission.Warnings, error) <span class="cov3" title="2">{
        return p.validate(obj)
}</span>

// ValidateUpdate validates the object on update.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (p *planValidatingHook) ValidateUpdate(_ context.Context, _ runtime.Object, newObj runtime.Object) (admission.Warnings, error) <span class="cov3" title="2">{
        return p.validate(newObj)
}</span>

// ValidateDelete validates the object on deletion.
// The optional warnings will be added to the response as warning messages.
// Return an error if the object is invalid.
func (*planValidatingHook) ValidateDelete(_ context.Context, _ runtime.Object) (admission.Warnings, error) <span class="cov1" title="1">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package upgradecontroller

import (
        "github.com/heathcliff26/kube-upgrade/pkg/upgrade-controller/controller"
        "github.com/heathcliff26/kube-upgrade/pkg/version"
        "k8s.io/klog/v2"

        "github.com/spf13/cobra"
)

const Name = "upgrade-controller"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgradeController()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to execute command: %v", err)
        }</span>
}

func NewUpgradeController() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " runs the controller to orchestrate cluster wide kubernetes upgrades.",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        run()
                        return nil
                }</span>,
        }

        <span class="cov8" title="1">rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run() <span class="cov0" title="0">{
        ctrl, err := controller.NewController(Name)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to create controller: %v", err)
        }</span>
        <span class="cov0" title="0">err = ctrl.Run()
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Controller exited with error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package config

import (
        "fmt"
        "log/slog"
        "os"
        "strings"

        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
        "sigs.k8s.io/yaml"
)

const (
        DefaultConfigDir  = "/etc/kube-upgraded/"
        DefaultConfigFile = "config.yaml"
        DefaultConfigPath = DefaultConfigDir + DefaultConfigFile
)

var logLevel = &amp;slog.LevelVar{}

// Initialize the logger
func init() <span class="cov5" title="5">{
        logLevel = &amp;slog.LevelVar{}
        opts := slog.HandlerOptions{
                Level: logLevel,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;opts))
        slog.SetDefault(logger)
}</span>

// Parse a given string and set the resulting log level
func setLogLevel(level string) error <span class="cov9" title="19">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov4" title="3">
                logLevel.Set(slog.LevelDebug)</span>
        case "info":<span class="cov7" title="10">
                logLevel.Set(slog.LevelInfo)</span>
        case "warn":<span class="cov3" title="2">
                logLevel.Set(slog.LevelWarn)</span>
        case "error":<span class="cov3" title="2">
                logLevel.Set(slog.LevelError)</span>
        default:<span class="cov3" title="2">
                return NewErrUnknownLogLevel(level)</span>
        }
        <span class="cov9" title="17">return nil</span>
}

func DefaultConfig() *api.UpgradedConfig <span class="cov10" title="20">{
        cfg := &amp;api.UpgradedConfig{}
        api.SetObjectDefaults_UpgradedConfig(cfg)
        return cfg
}</span>

// Loads the config from the given path.
// When path is empty, it checks the default path "/etc/kube-upgraded/config.yaml".
// When no config is found in the default path, it returns the default config.
// Returns error when the given config is invalid.
func LoadConfig(path string) (*api.UpgradedConfig, error) <span class="cov9" title="18">{
        c := DefaultConfig()

        if path == "" </span><span class="cov0" title="0">{
                path = DefaultConfigPath
        }</span>

        // #nosec G304: File will be passed by controller
        <span class="cov9" title="18">f, err := os.ReadFile(path)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov9" title="16">err = yaml.Unmarshal(f, &amp;c)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="15">err = ValidateConfig(c)
        if err != nil </span><span class="cov6" title="6">{
                return nil, err
        }</span>

        <span class="cov7" title="9">err = setLogLevel(c.LogLevel)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="8">return c, nil</span>
}

// Validates the given config to ensure all required fields are set.
func ValidateConfig(cfg *api.UpgradedConfig) error <span class="cov9" title="15">{
        if cfg == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid config, config is nil")
        }</span>
        <span class="cov8" title="14">if cfg.Stream == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid config, missing stream")
        }</span>
        <span class="cov8" title="13">if cfg.FleetlockURL == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid config, missing fleetlockUrl")
        }</span>
        <span class="cov8" title="12">if cfg.FleetlockGroup == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid config, missing fleetlockGroup")
        }</span>
        <span class="cov8" title="11">if cfg.KubeletConfig == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid config, missing kubeletConfig")
        }</span>
        <span class="cov7" title="10">if cfg.KubeadmPath == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid config, missing kubeadmPath")
        }</span>
        <span class="cov7" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package config

type ErrUnknownLogLevel struct {
        level string
}

func NewErrUnknownLogLevel(level string) error <span class="cov10" title="3">{
        return &amp;ErrUnknownLogLevel{
                level: level,
        }
}</span>

func (e *ErrUnknownLogLevel) Error() string <span class="cov0" title="0">{
        return "Unknown log level " + e.level
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "path/filepath"
        "time"

        "github.com/fsnotify/fsnotify"
        fleetlock "github.com/heathcliff26/fleetlock/pkg/client"
        api "github.com/heathcliff26/kube-upgrade/pkg/apis/kubeupgrade/v1alpha3"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
)

// Reload the daemon configuration from it's config file
func (d *daemon) UpdateFromConfigFile() error <span class="cov7" title="4">{
        slog.Info("Attempting to update daemon configuration from config file", slog.String("path", d.cfgPath))

        cfg, err := config.LoadConfig(d.cfgPath)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to load config from file: %v", err)
        }</span>

        <span class="cov5" title="3">return d.updateFromConfig(cfg)</span>
}

// Update the daemon configuration from the provided config object.
// Ensures that no changes will be made if there are errors in the config.
func (d *daemon) updateFromConfig(cfg *api.UpgradedConfig) error <span class="cov10" title="8">{
        checkInterval, err := time.ParseDuration(cfg.CheckInterval)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to parse check interval \"%s\": %v", cfg.CheckInterval, err)
        }</span>
        <span class="cov9" title="7">retryInterval, err := time.ParseDuration(cfg.RetryInterval)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to parse retry interval \"%s\": %v", cfg.RetryInterval, err)
        }</span>

        <span class="cov8" title="6">fleetlockClient, err := fleetlock.NewClient(cfg.FleetlockURL, cfg.FleetlockGroup)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create fleetlock client with url '%s' and group '%s': %v", cfg.FleetlockURL, cfg.FleetlockGroup, err)
        }</span>

        <span class="cov7" title="5">d.Lock()
        defer d.Unlock()

        d.stream = cfg.Stream
        d.fleetlock = fleetlockClient
        d.checkInterval = checkInterval
        d.retryInterval = retryInterval

        slog.Info("Finished updating configuration")
        return nil</span>
}

// Create a new config file watcher that needs to be closed when done
func (d *daemon) NewConfigFileWatcher() error <span class="cov5" title="3">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config file watcher: %v", err)
        }</span>

        // Need to watch the directory instead of the file, as kubernetes uses symbolic links
        <span class="cov5" title="3">err = watcher.Add(filepath.Dir(d.cfgPath))
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to add config file to watcher: %v", err)
        }</span>

        <span class="cov4" title="2">d.configWatcher = watcher
        return nil</span>
}

func (d *daemon) WatchConfigFile() <span class="cov1" title="1">{
        slog.Info("Started watching the config file for changes", slog.String("path", d.cfgPath))

        for </span><span class="cov4" title="2">{
                select </span>{
                case event, ok := &lt;-d.configWatcher.Events:<span class="cov1" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                slog.Info("Config file watcher events channel closed")
                                return
                        }</span>
                        // Ignore chmod, rename and remove events, they are not relevant
                        <span class="cov1" title="1">if event.Has(fsnotify.Chmod | fsnotify.Rename | fsnotify.Remove) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov1" title="1">slog.Debug("Received event on config file directory", slog.String("Op", event.Op.String()), slog.String("name", event.Name))
                        // Check if the event is for our config file or the ..data symlink
                        if event.Name == d.cfgPath || event.Name == filepath.Join(filepath.Dir(d.cfgPath), "..data") </span><span class="cov1" title="1">{
                                err := d.UpdateFromConfigFile()
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Error("Failed to update configuration from config file", slog.String("path", d.cfgPath), slog.String("error", err.Error()))
                                }</span>
                        }
                case err, ok := &lt;-d.configWatcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                slog.Info("Config file watcher errors channel closed")
                                return
                        }</span>
                        <span class="cov0" title="0">slog.Error("Error watching config file", slog.String("path", d.cfgPath), slog.String("error", err.Error()))</span>
                case &lt;-d.ctx.Done():<span class="cov1" title="1">
                        // Daemon is stopping
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/fsnotify/fsnotify"
        fleetlock "github.com/heathcliff26/fleetlock/pkg/client"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/config"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm"
        rpmostree "github.com/heathcliff26/kube-upgrade/pkg/upgraded/rpm-ostree"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/clientcmd"
)

var (
        hostPrefix       = "/host"
        rpmOstreeCMDPath = "/usr/bin/rpm-ostree"
)

type daemon struct {
        cfgPath string

        stream        string
        fleetlock     *fleetlock.FleetlockClient
        checkInterval time.Duration
        retryInterval time.Duration

        rpmostree *rpmostree.RPMOStreeCMD
        kubeadm   *kubeadm.KubeadmCMD

        node string

        client kubernetes.Interface
        ctx    context.Context
        cancel context.CancelFunc

        configWatcher *fsnotify.Watcher

        sync.Mutex
}

// Create a new daemon
func NewDaemon(cfgPath string) (*daemon, error) <span class="cov5" title="3">{
        cfg, err := config.LoadConfig(cfgPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load config: %v", err)
        }</span>
        <span class="cov5" title="3">if cfgPath == "" </span><span class="cov0" title="0">{
                cfgPath = config.DefaultConfigPath
        }</span>

        // Hardcoded path, as it will be executed in a container
        <span class="cov5" title="3">rpmOstreeCMD, err := rpmostree.New(rpmOstreeCMDPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create rpm-ostree cmd wrapper: %v", err)
        }</span>
        <span class="cov5" title="3">kubeadmCMD, err := kubeadm.New(hostPrefix, cfg.KubeadmPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create kubeadm cmd wrapper: %v", err)
        }</span>

        <span class="cov4" title="2">config, err := clientcmd.BuildConfigFromFlags("", hostPrefix+cfg.KubeletConfig)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read kubeconfig: %v", err)
        }</span>
        <span class="cov1" title="1">kubeClient, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %v", err)
        }</span>

        <span class="cov1" title="1">machineID, err := utils.GetMachineID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get machine-id: %v", err)
        }</span>
        <span class="cov1" title="1">node, err := findNode(kubeClient, machineID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get kubernetes node name for host: %v", err)
        }</span>
        <span class="cov0" title="0">slog.Info("Found node name for this host", slog.String("node", node))

        d := &amp;daemon{
                cfgPath: cfgPath,

                rpmostree: rpmOstreeCMD,
                kubeadm:   kubeadmCMD,

                node:   node,
                client: kubeClient,
        }

        err = d.updateFromConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return d, nil</span>
}

// Retries the given function until it succeeds
func (d *daemon) retry(f func() bool) <span class="cov5" title="3">{
        for !f() </span><span class="cov10" title="8">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-time.After(d.retryInterval):<span class="cov9" title="7"></span>
                }
        }
}

// Will try to release the lock until successful
func (d *daemon) releaseLock() <span class="cov1" title="1">{
        d.retry(func() bool </span><span class="cov1" title="1">{
                err := d.fleetlock.Release()
                if err == nil </span><span class="cov1" title="1">{
                        return true
                }</span>

                <span class="cov0" title="0">slog.Warn("Failed to release lock", "err", err)
                return false</span>
        })
}

// Run the main daemon loop
func (d *daemon) Run() error <span class="cov4" title="2">{
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGTERM)
        ctx, cancel := context.WithCancel(context.Background())
        d.ctx = ctx
        d.cancel = cancel
        go func() </span><span class="cov4" title="2">{
                &lt;-stop
                cancel()
        }</span>()

        <span class="cov4" title="2">err := d.rpmostree.RegisterAsDriver()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to register upgraded as driver for rpm-ostree: %v", err)
        }</span>

        <span class="cov1" title="1">node, err := d.getNode()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get node status: %v", err)
        }</span>

        <span class="cov0" title="0">node, err = d.annotateNodeWithUpgradedVersion(node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to annotate node with upgraded version: %v", err)
        }</span>

        <span class="cov0" title="0">if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                slog.Debug("Releasing any log that may be held by this machine")
                d.releaseLock()
                if d.ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                slog.Info("Node needs upgrade or is in the middle of one, upgrading node before starting daemon")
                d.doNodeUpgradeWithRetry(node)
        }</span>

        <span class="cov0" title="0">err = d.NewConfigFileWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config file watcher: %v", err)
        }</span>
        <span class="cov0" title="0">defer d.configWatcher.Close()

        slog.Info("Starting daemon")

        var wg sync.WaitGroup
        wg.Add(3)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForUpgrade()
                slog.Info("Stopped watching for upgrades")
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.watchForNodeUpgrade()
                slog.Info("Stopped watching for kubernetes upgrades")
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                d.WatchConfigFile()
                slog.Info("Stopped watching config file")
        }</span>()

        <span class="cov0" title="0">wg.Wait()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/kubeadm"
        "github.com/heathcliff26/kube-upgrade/pkg/version"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/tools/cache"
        "sigs.k8s.io/yaml"
)

const kubernetesTMPDir = "/etc/kubernetes/tmp"

// Watch for node upgrades and perform them if necessary
func (d *daemon) watchForNodeUpgrade() <span class="cov0" title="0">{
        factory := informers.NewSharedInformerFactoryWithOptions(d.client, time.Minute, informers.WithTweakListOptions(func(opts *metav1.ListOptions) </span><span class="cov0" title="0">{
                opts.FieldSelector = fields.SelectorFromSet(fields.Set{"metadata.name": d.node}).String()
        }</span>))

        <span class="cov0" title="0">informer := factory.Core().V1().Nodes().Informer()
        _, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                UpdateFunc: func(_, newObj interface{}) </span><span class="cov0" title="0">{
                        node := newObj.(*corev1.Node)
                        d.checkNodeStatus(node)
                }</span>,
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to add event handlers to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">err = informer.SetWatchErrorHandlerWithContext(cache.DefaultWatchErrorHandler)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to set watch error handler to kubernetes informer")
                d.cancel()
                return
        }</span>
        <span class="cov0" title="0">slog.Info("Watching for new kubernetes upgrades")
        informer.Run(d.ctx.Done())</span>
}

// Check if we need to upgrade the node and trigger the upgrade if needed
func (d *daemon) checkNodeStatus(node *corev1.Node) <span class="cov0" title="0">{
        if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">d.doNodeUpgradeWithRetry(nil)</span>
}

// Update the node until it succeeds
func (d *daemon) doNodeUpgradeWithRetry(node *corev1.Node) <span class="cov1" title="1">{
        d.retry(func() bool </span><span class="cov5" title="3">{
                err := d.doNodeUpgrade(node)
                if err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov5" title="3">slog.Error("Failed to upgrade node", "err", err, slog.String("node", d.node))
                return false</span>
        })
}

// Update the node by first rebasing to a new version and then upgrading kubernetes
func (d *daemon) doNodeUpgrade(node *corev1.Node) error <span class="cov8" title="6">{
        d.Lock()
        defer d.Unlock()

        var err error
        if node == nil </span><span class="cov5" title="3">{
                // Need to fetch fresh data here, as the informer might called with a stale node version
                node, err = d.getNode()
                if err != nil </span><span class="cov5" title="3">{
                        return fmt.Errorf("failed to get node data from server: %v", err)
                }</span>
                <span class="cov0" title="0">if !nodeNeedsUpgrade(node) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov5" title="3">version := node.Annotations[constants.NodeKubernetesVersion]
        slog.Info("Attempting node upgrade to new kubernetes version", slog.String("node", node.GetName()), slog.String("version", version))

        err = d.fleetlock.Lock()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to acquire lock: %v", err)
        }</span>

        <span class="cov3" title="2">if version != d.kubeadm.Version() </span><span class="cov3" title="2">{
                slog.Info("Rebasing os to new kubernetes version", slog.String("version", version), slog.String("current", d.kubeadm.Version()))
                err := d.updateNodeStatus(constants.NodeUpgradeStatusRebasing)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update node status: %v", err)
                }</span>
                <span class="cov3" title="2">err = d.rpmostree.Rebase(d.stream + ":" + version)
                if err != nil </span><span class="cov1" title="1">{
                        return d.returnNodeUpgradeError(fmt.Errorf("failed to rebase node: %v", err))
                }</span>
                // This return is here purely for testing, as a successful rebase does not return, but instead reboots the system
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov0" title="0">slog.Info("Updating node via kubeadm")

        err = d.updateNodeStatus(constants.NodeUpgradeStatusUpgrading)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        <span class="cov0" title="0">kubeadmConfigMap, err := d.client.CoreV1().ConfigMaps("kube-system").Get(d.ctx, "kubeadm-config", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("failed to fetch kubeadm-config: %v", err))
        }</span>
        <span class="cov0" title="0">if kubeadmConfigMap.Data == nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("kubeadm configmap contains no data"))
        }</span>
        <span class="cov0" title="0">var kubeadmConfig kubeadm.ClusterConfiguration
        err = yaml.Unmarshal([]byte(kubeadmConfigMap.Data["ClusterConfiguration"]), &amp;kubeadmConfig)
        if err != nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("failed to parse kubeadm-config: %v", err))
        }</span>

        <span class="cov0" title="0">if version != kubeadmConfig.KubernetesVersion </span><span class="cov0" title="0">{
                slog.Info("kubeadm-config kubernetesVersion does not match requested version, initializing upgrade", slog.String("kubernetesVersion", kubeadmConfig.KubernetesVersion), slog.String("version", version))
                err = d.kubeadm.Apply(version)
        }</span> else<span class="cov0" title="0"> {
                slog.Debug("Cluster upgrade is already initialized, upgrading node")
                err = d.kubeadm.Node()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return d.returnNodeUpgradeError(fmt.Errorf("failed run kubeadm: %v", err))
        }</span>

        <span class="cov0" title="0">err = d.updateNodeStatus(constants.NodeUpgradeStatusCompleted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update node status: %v", err)
        }</span>

        // Cleanup tmp directory created by kubeadm.
        // If not deleted it may grow to large sizes over multiple upgrades.
        <span class="cov0" title="0">err = deleteDir(kubernetesTMPDir)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("Failed to delete temporary kubernetes directory", slog.String("path", kubernetesTMPDir), slog.Any("error", err))
        }</span>

        <span class="cov0" title="0">slog.Info("Finished node upgrade, releasing lock")
        d.releaseLock()
        return nil</span>
}

// Update the kube-upgrade node status annotation with the given status
func (d *daemon) updateNodeStatus(status string) error <span class="cov8" title="6">{
        node, err := d.getNode()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov7" title="5">if node.Annotations == nil </span><span class="cov1" title="1">{
                node.Annotations = make(map[string]string)
        }</span>
        <span class="cov7" title="5">node.Annotations[constants.NodeUpgradeStatus] = status

        _, err = d.client.CoreV1().Nodes().Update(d.ctx, node, metav1.UpdateOptions{})
        if err == nil </span><span class="cov7" title="5">{
                slog.Debug("Set node status", slog.String("status", status))
        }</span>
        <span class="cov7" title="5">return err</span>
}

// Retrieve the node from the API
func (d *daemon) getNode() (*corev1.Node, error) <span class="cov10" title="10">{
        return d.client.CoreV1().Nodes().Get(d.ctx, d.node, metav1.GetOptions{})
}</span>

// Return the given error, but also set the node status to error
func (d *daemon) returnNodeUpgradeError(err error) error <span class="cov1" title="1">{
        statusErr := d.updateNodeStatus(constants.NodeUpgradeStatusError)
        if statusErr != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to set node to error status", slog.Any("error", statusErr))
        }</span>
        <span class="cov1" title="1">return err</span>
}

// Annotate the node with the current upgraded version
func (d *daemon) annotateNodeWithUpgradedVersion(node *corev1.Node) (*corev1.Node, error) <span class="cov5" title="3">{
        if node.Annotations == nil </span><span class="cov1" title="1">{
                node.Annotations = make(map[string]string)
        }</span>

        <span class="cov5" title="3">if node.Annotations[constants.NodeUpgradedVersion] == version.Version() </span><span class="cov1" title="1">{
                return node, nil
        }</span>

        <span class="cov3" title="2">node.Annotations[constants.NodeUpgradedVersion] = version.Version()
        return d.client.CoreV1().Nodes().Update(d.ctx, node, metav1.UpdateOptions{})</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package daemon

import (
        "fmt"
        "log/slog"
        "time"
)

// Check for os upgrades and perform them if necessary.
// Runs until context is cancelled
func (d *daemon) watchForUpgrade() <span class="cov0" title="0">{
        var needUpgrade bool
        for </span><span class="cov0" title="0">{
                d.retry(func() bool </span><span class="cov0" title="0">{
                        var err error
                        slog.Debug("Checking for upgrades via rpm-ostree")
                        needUpgrade, err = d.rpmostree.CheckForUpgrade()
                        if err == nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">slog.Error("Failed to check if there is a new upgrade", "err", err)
                        return false</span>
                })

                <span class="cov0" title="0">if needUpgrade </span><span class="cov0" title="0">{
                        slog.Info("New upgrade is necessary, trying to start update")
                        d.retry(func() bool </span><span class="cov0" title="0">{
                                err := d.doUpgrade()
                                if err == nil </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                                <span class="cov0" title="0">slog.Error("Failed to perform rpm-ostree upgrade", "err", err)
                                return false</span>
                        })
                } else<span class="cov0" title="0"> {
                        slog.Debug("No upgrades found")
                }</span>

                <span class="cov0" title="0">select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(d.checkInterval):<span class="cov0" title="0"></span>
                }
        }
}

// Perform rpm-ostree upgrade
func (d *daemon) doUpgrade() error <span class="cov10" title="3">{
        d.Lock()
        defer d.Unlock()

        err := d.fleetlock.Lock()
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to acquire lock: %v", err)
        }</span>

        <span class="cov6" title="2">err = d.rpmostree.Upgrade()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // This should not be reached, as rpmostree.Upgrade() reboots the node on success.
        // I included it here mainly for completeness sake.

        <span class="cov1" title="1">d.releaseLock()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package daemon

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "strings"

        "github.com/heathcliff26/kube-upgrade/pkg/constants"
        authenticationv1 "k8s.io/api/authentication/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

// Find the node. It will try various methods and confirm them via the machine id.
// The methods are in order:
//   - whoami api call
//   - listing all nodes and iterating over them. (This does not work anymore with k8s 1.32+)
func findNode(client kubernetes.Interface, machineID string) (string, error) <span class="cov1" title="1">{
        node, err := findNodeViaWhoami(client, machineID)
        if err == nil </span><span class="cov0" title="0">{
                return node, nil
        }</span>
        <span class="cov1" title="1">slog.Info("Failed to find node via whoami call, trying by listing all nodes next", "err", err)

        return findNodeByListingAllNodes(client, machineID)</span>
}

// Call kubernetes auth api and ask whoami
func findNodeViaWhoami(client kubernetes.Interface, machineID string) (string, error) <span class="cov1" title="1">{
        res, err := client.AuthenticationV1().SelfSubjectReviews().Create(context.Background(), &amp;authenticationv1.SelfSubjectReview{}, metav1.CreateOptions{})
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov0" title="0">name, _ := strings.CutPrefix(res.Status.UserInfo.Username, "system:node:")
        slog.Info("Found username via auth whoami", slog.String("username", res.Status.UserInfo.Username), slog.String("node", name))

        node, err := client.CoreV1().Nodes().Get(context.Background(), name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if node.Status.NodeInfo.MachineID != machineID </span><span class="cov0" title="0">{
                return "", fmt.Errorf("found node \"%s\", but machine id does not match", name)
        }</span>
        <span class="cov0" title="0">return name, nil</span>
}

// Find the node by iterating over all nodes and comparing machine ids
func findNodeByListingAllNodes(client kubernetes.Interface, machineID string) (string, error) <span class="cov5" title="2">{
        nodes, err := client.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov1" title="1">for _, node := range nodes.Items </span><span class="cov1" title="1">{
                if node.Status.NodeInfo.MachineID == machineID </span><span class="cov1" title="1">{
                        return node.GetName(), nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("found no node with matching machineID: %s", machineID)</span>
}

// Check if the node needs to upgrade it's kubernetes version
func nodeNeedsUpgrade(node *corev1.Node) bool <span class="cov10" title="4">{
        if node.Annotations == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="3">status := node.Annotations[constants.NodeUpgradeStatus]
        if status == constants.NodeUpgradeStatusCompleted </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov5" title="2">if _, ok := node.Annotations[constants.NodeKubernetesVersion]; !ok </span><span class="cov1" title="1">{
                slog.Warn("Missing version annotation on node", slog.String("node", node.GetName()), slog.String("annotation", constants.NodeKubernetesVersion))
                return false
        }</span>
        <span class="cov1" title="1">return true</span>
}

// Delete the specified directory if it exists
func deleteDir(path string) error <span class="cov5" title="2">{
        if _, err := os.Stat(path); !os.IsNotExist(err) </span><span class="cov1" title="1">{
                return os.RemoveAll(path)
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package kubeadm

import (
        "fmt"
        "os/exec"
        "strings"
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type KubeadmCMD struct {
        binary  string
        chroot  string
        mutex   sync.Mutex
        version string
}

// Create a new wrapper for kubeadm.
// The binary will run in the provided chroot.
func New(chroot, path string) (*KubeadmCMD, error) <span class="cov10" title="8">{
        err := utils.CheckExistsAndIsExecutable(chroot + path)
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov8" title="6">k := &amp;KubeadmCMD{
                binary: path,
                chroot: chroot,
        }

        k.version, err = k.getVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read kubeadm version: %v", err)
        }</span>
        <span class="cov8" title="6">k.version, _ = strings.CutSuffix(k.version, "\n")

        return k, nil</span>
}

// Run kubeadm upgrade apply
func (k *KubeadmCMD) Apply(version string) error <span class="cov1" title="1">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateChrootCMDWithStdout(k.chroot, k.binary, "upgrade", "apply", "--yes", version).Run()
}</span>

// Run kubeadm upgrade node
func (k *KubeadmCMD) Node() error <span class="cov0" title="0">{
        k.mutex.Lock()
        defer k.mutex.Unlock()

        return utils.CreateChrootCMDWithStdout(k.chroot, k.binary, "upgrade", "node").Run()
}</span>

func (k *KubeadmCMD) Version() string <span class="cov7" title="4">{
        return k.version
}</span>

func (k *KubeadmCMD) getVersion() (string, error) <span class="cov8" title="6">{
        // #nosec G204: Binary path is controlled by the user
        out, err := exec.Command(k.chroot+k.binary, "version", "--output", "short").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="6">return string(out), nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package upgraded

import (
        "log/slog"
        "os"
        "os/user"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/daemon"
        "github.com/heathcliff26/kube-upgrade/pkg/version"

        "github.com/spf13/cobra"
)

const Name = "upgraded"

func Execute() <span class="cov0" title="0">{
        cmd := NewUpgraded()
        err := cmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Command exited with error", "err", err)
                os.Exit(1)
        }</span>
}

func NewUpgraded() *cobra.Command <span class="cov8" title="1">{
        cobra.AddTemplateFunc(
                "ProgramName", func() string </span><span class="cov0" title="0">{
                        return Name
                }</span>,
        )

        <span class="cov8" title="1">rootCmd := &amp;cobra.Command{
                Use:   Name,
                Short: Name + " daemon for keeping the system up-to-date",
                Run: func(cmd *cobra.Command, _ []string) </span><span class="cov0" title="0">{
                        cfg, err := cmd.Flags().GetString("config")
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Failed to parse config file flag", "err", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">run(cfg)</span>
                },
        }

        <span class="cov8" title="1">rootCmd.Flags().StringP("config", "c", "", "Path to config file")
        rootCmd.AddCommand(
                version.NewCommand(Name),
        )

        return rootCmd</span>
}

func run(cfgPath string) <span class="cov0" title="0">{
        u, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to check if running as root", "err", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if u.Username != "root" </span><span class="cov0" title="0">{
                slog.Error("Need to be root")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">d, err := daemon.NewDaemon(cfgPath)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to create a new daemon", "err", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = d.Run()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Daemon exited with error", "err", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package rpmostree

import (
        "fmt"
        "os/exec"
        "sync"

        "github.com/heathcliff26/kube-upgrade/pkg/upgraded/utils"
)

type RPMOStreeCMD struct {
        binary string
        mutex  sync.Mutex
}

// Create a new wrapper for rpm-ostree
func New(path string) (*RPMOStreeCMD, error) <span class="cov10" title="16">{
        err := utils.CheckExistsAndIsExecutable(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="15">return &amp;RPMOStreeCMD{
                binary: path,
        }, nil</span>
}

// Run rpm-ostree and check for new updates
func (r *RPMOStreeCMD) CheckForUpgrade() (bool, error) <span class="cov4" title="3">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        // #nosec G204: Binary path is controlled by the user
        cmd := exec.Command(r.binary, "upgrade", "--check")
        out, err := cmd.CombinedOutput()
        code, ok := getExitCode(err)
        if !ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                fmt.Println(string(out))
                return false, err
        }</span> else<span class="cov4" title="3"> if err == nil </span><span class="cov1" title="1">{
                code = 0
        }</span>

        <span class="cov4" title="3">switch code </span>{
        case 0:<span class="cov1" title="1">
                return true, nil</span>
        case 77:<span class="cov1" title="1">
                return false, nil</span>
        default:<span class="cov1" title="1">
                fmt.Println(string(out))
                return false, fmt.Errorf("rpm-ostree exited with unknown exit code %d", code)</span>
        }
}

// Upgrade the system using rpm-ostree. Writes command output to stdout/stderr.
//
// WARNING: Will reboot the system when successful.
func (r *RPMOStreeCMD) Upgrade() error <span class="cov3" title="2">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "upgrade", "--reboot").Run()
}</span>

// Rebases the system to the given container image
//
// WARNING: Will reboot the system when successful.
func (r *RPMOStreeCMD) Rebase(image string) error <span class="cov4" title="3">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "rebase", "--reboot", "ostree-unverified-registry:"+image).Run()
}</span>

// Register upgraded as the driver for updates with rpm-ostree.
// This will prevent the user from calling rpm-ostree directly, unless they bypass the check.
func (r *RPMOStreeCMD) RegisterAsDriver() error <span class="cov3" title="2">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        return utils.CreateCMDWithStdout(r.binary, "deploy", "--register-driver=upgraded").Run()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package rpmostree

import (
        "os/exec"
)

// Try to extract the exit code from the error.
func getExitCode(err error) (int, bool) <span class="cov10" title="3">{
        if exiterr, ok := err.(*exec.ExitError); ok </span><span class="cov6" title="2">{
                return exiterr.ExitCode(), true
        }</span>
        <span class="cov1" title="1">return 0, false</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package utils

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
        "syscall"
)

// Read the machine-id from /etc/machine-id
func GetMachineID() (string, error) <span class="cov2" title="2">{
        b, err := os.ReadFile("/etc/machine-id")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov2" title="2">machineID := strings.TrimRight(string(b), "\r\n")
        return machineID, nil</span>
}

// Create a command that writes to stdout/stderr
func CreateCMDWithStdout(name string, arg ...string) *exec.Cmd <span class="cov7" title="9">{
        cmd := exec.Command(name, arg...)
        cmd.Stderr = os.Stderr
        cmd.Stdout = os.Stdout
        return cmd
}</span>

// Create a command that runs in a chroot and writes to stdout/stderr
func CreateChrootCMDWithStdout(chrootPath string, name string, arg ...string) *exec.Cmd <span class="cov1" title="1">{
        cmd := CreateCMDWithStdout(name, arg...)
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Chroot: chrootPath,
        }
        return cmd
}</span>

// Check if the given file exists and is executable
func CheckExistsAndIsExecutable(path string) error <span class="cov10" title="27">{
        f, err := os.Stat(path)
        if err != nil </span><span class="cov4" title="4">{
                return err
        }</span>
        <span class="cov9" title="23">if f.Mode().Perm()&amp;0100 == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("%s is not an executable", path)
        }</span>
        <span class="cov9" title="22">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package version

import (
        "runtime"
        "runtime/debug"

        "github.com/spf13/cobra"
)

// Create a new version command with the given app name
func NewCommand(name string) *cobra.Command <span class="cov4" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information and exit",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        cmd.Print(VersionInfoString(name))
                }</span>,
        }
        // Override to prevent parent function from running
        <span class="cov4" title="3">cmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span>{<span class="cov0" title="0">}</span>

        <span class="cov4" title="3">return cmd</span>
}

// Return the version string
func Version() string <span class="cov10" title="16">{
        buildinfo, _ := debug.ReadBuildInfo()
        return buildinfo.Main.Version
}</span>

// Return a formatted string containing the version, git commit and go version the app was compiled with.
func VersionInfoString(name string) string <span class="cov1" title="1">{
        var commit string
        buildinfo, _ := debug.ReadBuildInfo()
        for _, item := range buildinfo.Settings </span><span class="cov9" title="13">{
                if item.Key == "vcs.revision" </span><span class="cov0" title="0">{
                        commit = item.Value
                        break</span>
                }
        }
        <span class="cov1" title="1">if len(commit) &gt; 7 </span><span class="cov0" title="0">{
                commit = commit[:7]
        }</span> else<span class="cov1" title="1"> if commit == "" </span><span class="cov1" title="1">{
                commit = "Unknown"
        }</span>

        <span class="cov1" title="1">result := name + ":\n"
        result += "    Version: " + buildinfo.Main.Version + "\n"
        result += "    Commit:  " + commit + "\n"
        result += "    Go:      " + runtime.Version() + "\n"

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
